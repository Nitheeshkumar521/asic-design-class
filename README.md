# ASIC DESIGN CLASS

## LAB 1 - Create a C program which will caluculate sum from 1 to n, And compile it using GCC compilier

1)- Write a C program in text editor as sum 1 to n  

Following image will show about the image of the C program 

![image1lab1](https://github.com/user-attachments/assets/bdd30330-f82b-488c-ba6f-2216d53d4d38)

2- Compile the code using GCC compiler and run the code to see the output

Image will show about the commands used and output of sum1ton

![image2lab1](https://github.com/user-attachments/assets/c247d982-e748-4ed9-9ed5-bcae0e249202)

## LAB 2 - Compiling Lab1(sum 1 to n) C program with RISCV Compiler

1) We will run lab 1 program using RISCV Gcc compiler


![image1lab2](https://github.com/user-attachments/assets/44bf2daf-6c83-4f52-86ad-afb83a292f7c)

2)In a new tab we will check the assembly code for C program we Run

Here we went to the "main"  when I calculted using calculator got (35)dec and (23)hex 

![img3lab2](https://github.com/user-attachments/assets/d5ab9bb2-d94f-4b70-8e69-0277e7e2aabd)

4) Hence now we will use Ofast on the RISCV compiler and we will use the same C code 
image which describes about the commands


![img5lab2](https://github.com/user-attachments/assets/816cc5e4-374e-4de9-95da-b0ec6eb3158c)

5) We got 12 instructions(byte adressing) in the main section (adress 100bo)

![img6lab2](https://github.com/user-attachments/assets/3a3c8018-28fa-4629-b4c8-d561402dbbbb)

6) RISCV compilation output
 Code Compilation using RISC-V GCC compiler with a different optimization flag (Ofast)
we will compile the code with compiler flag set as -Ofast and then we will check the assembly code again
![lab 2 8](https://github.com/user-attachments/assets/9d590d74-02ef-4005-887b-16107e7326a1)
![lab 2 9](https://github.com/user-attachments/assets/f882ce66-3843-4c09-81e2-ae3fef84b769)

# LAB3-DEBBUGGING WITH SPIKE SIMULATOR AND RUNNING THE OBJECT FILE GENERATED BY RISCV COMPILER IN SPIKE STIMULATOR

1) Debug it in spike using below command and we need our program counter to run till 100b0 by using the below command
   ![lab 3 1](https://github.com/user-attachments/assets/d744c0d1-b465-4ec6-b4a5-02e805546aaf)

2) Next we have to modify the content of a0 below command
press enter then it will run the next instruction is lui a0,0*21
And then we will ger the next instruction as addi sp,sp,-16
![lab 3 3](https://github.com/user-attachments/assets/1f3a1111-bd80-4306-a799-d8f71cb4dbef)


3)As stack pointer content updated by -16. Quit the spike by pressing q 
![lab 3 4](https://github.com/user-attachments/assets/a1440c67-95cf-44d4-a004-9d784f0ac688)

4)And we will follow the steps as follow from step1(Enter the spike stimulation again)
![Screenshot 2024-07-28 131139](https://github.com/user-attachments/assets/ffe17813-aed3-4399-9f54-e1d929df54a2)

Hex value
3ffffffb50-3ffffffb40=10 , 
Dec value
274877905744-274877905728=16

# task 4
## RISC-V Instruction Types and Formats

### R-type: Used for register-register operations.

    Format: funct7 (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)

### I-type: Used for immediate operations.

    Format: imm[11:0] (12 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)
### S-type: Used for store operations.

    Format: imm[11:5] (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:0] (5 bits) | opcode (7 bits)
### B-type: Used for branch operations.

    Format: imm[12] (1 bit) | imm[10:5] (6 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:1] (4 bits) | imm[11] (1 bit) | opcode (7 bits)
### U-type: Used for upper immediate operations.

    Format: imm[31:12] (20 bits) | rd (5 bits) | opcode (7 bits)
### J-type: Used for jump operations.

    Format: imm[20] (1 bit) | imm[10:1] (10 bits) | imm[11] (1 bit) | imm[19:12] (8 bits) | rd (5 bits) | opcode (7 bits)
## Encoded Instructions
### ADD r0, r1, r2

    Type: R
    Encoding: 0000000 00010 00001 000 00000 0110011
    Binary: 00000000001000001000000000110011
### SUB r2, r0, r1

    Type: R
    Encoding: 0100000 00000 00001 000 00010 0110011
    Binary: 01000000000000001000000010110011
### AND r1, r0, r2

    Type: R
    Encoding: 0000000 00010 00000 111 00001 0110011
    Binary: 00000000001000000111000010110011
### OR r8, r1, r5

    Type: R
    Encoding: 0000000 00101 00001 110 01000 0110011
    Binary: 00000000010100001110010000110011
### XOR r8, r0, r4

    Type: R
    Encoding: 0000000 00100 00000 100 01000 0110011
    Binary: 00000000010000000100010000110011
### SLT r0, r1, r4

    Type: R
    Encoding: 0000000 00100 00001 010 00000 0110011
    Binary: 00000000010000001010000000110011
### ADDI r2, r2, 5

    Type: I
    Encoding: 000000000101 00010 000 00010 0010011
    Binary: 00000000010100010000000010010011
### SW r2, r0, 4

    Type: S
    Encoding: 0000000 00010 00000 010 00100 0100011
    Binary: 00000000001000000010001000100011
### SRL r6, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 101 00110 0110011
    Binary: 00000000000100001101000110110011
### BNE r0, r0, 20

    Type: B
    Encoding: 000000 00000 00000 001 01000 1100011
    Binary: 00000000000000000001001000110011
### BEQ r0, r0, 15

    Type: B
    Encoding: 000000 00000 00000 000 01111 1100011
    Binary: 00000000000000000000001111110011
### LW r3, r1, 2

    Type: I
    Encoding: 000000000010 00001 010 00011 0000011
    Binary: 00000000001000001010000011000011
### SLL r5, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 001 00101 0110011
    Binary: 00000000000100001001000101110011

# RISC-V INSTRUCTIONS AND THEIR HEXADECIAMAL REPRESENTATION:

| Instruction       | Type | 32-bit Binary Representation    | Hexadecimal |
|-------------------|------|---------------------------------|-------------|
| `ADD r0, r1, r2`  | R    | `0000000 00010 00001 000 00000 0110011` | `0x00008033` |
| `SUB r2, r0, r1`  | R    | `0100000 00001 00000 000 00010 0110011` | `0x40000033` |
| `AND r1, r0, r2`  | R    | `0000000 00010 00000 111 00001 0110011` | `0x0000F033` |
| `OR r8, r1, r5`   | R    | `0000000 00101 00001 110 01000 0110011` | `0x0050C333` |
| `XOR r8, r0, r4`  | R    | `0000000 00100 00000 100 01000 0110011` | `0x00408333` |
| `SLT r0, r1, r4`  | R    | `0000000 00100 00001 010 00000 0110011` | `0x00408033` |
| `ADDI r2, r2, 5`  | I    | `000000000101 00010 000 00010 0010011` | `0x00510113` |
| `SW r2, r0, 4`    | S    | `0000000 00010 00000 010 00100 0100011` | `0x00202223` |
| `SRL r6, r1, r1`  | R    | `0000000 00001 00001 101 00110 0110011` | `0x0012D333` |
| `BNE r0, r0, 20`  | B    | `000000 00000 00000 001 00101 1100011` | `0x01400063` |
| `BEQ r0, r0, 15`  | B    | `000000 00000 00000 000 00011 1100011` | `0x00F00063` |
| `LW r3, r1, 2`    | I    | `000000000010 00001 010 00011 0000011` | `0x00212283` |
| `SLL r5, r1, r1`  | R    | `0000000 00001 00001 001 00101 0110011` | `0x00109133` |



| Instruction        | Type | 32-bit Instruction Code                        | Binary Representation            | Hexadecimal Representation |
|--------------------|------|------------------------------------------------|----------------------------------|-----------------------------|
| ADD r0, r1, r2  | R    | 0000000 00010 00001 000 00000 0110011       | 00000000001000001000000000110011 | 0x00028233 |
| SUB r2, r0, r1  | R    | 0100000 00001 00000 000 00010 0110011       | 01000000000100000000000000110011 | 0x40028033 |
| AND r1, r0, r2  | R    | 0000000 00010 00000 111 00001 0110011       | 00000000001000000111100000110011 | 0x0000f033 |
| OR r8, r1, r5   | R    | 0000000 00101 00001 110 01000 0110011       | 00000000010100001110010000110011 | 0x0002e433 |
| XOR r8, r0, r4  | R    | 0000000 00100 00000 100 01000 0110011       | 00000000010000000100100000110011 | 0x00029033 |
| SLT r00, r1, r4 | R    | 0000000 00100 00001 010 00000 0110011       | 00000000010000001010000000110011 | 0x0002a033 |
| ADDI r02, r2, 5 | I    | 000000000101 00010 000 00010 0010011       | 0000000001010001000000000010011 | 0x0002a013 |
| SW r2, r0, 4    | S    | 000000000100 00000 010 00010 0100011       | 00000000010000000001000000100011 | 0x00008023 |
| SRL r06, r01, r1| R    | 0000000 00001 00001 101 00110 0110011       | 00000000001000001010100110011001 | 0x0002a033 |
| BNE r0, r0, 20  | B    | 000000000101 00000 001 00000 1100011       | 00000000010100000001000001100011 | 0x00014063 |
| BEQ r0, r0, 15  | B    | 000000000111 00000 000 00000 1100011       | 00000000011100000000000001100011 | 0x0000c063 |
| LW r03, r01, 2  | I    | 000000000010 00001 010 00011 0000011       | 00000000001000001010000010000011 | 0x00010283 |
| SLL r05, r01, r1| R    | 0000000 00001 00001 001 00101 0110011       | 00000000001000001001000100110011 | 0x00024033 |


# RISC-V AND HARDCODED ISA INSTUCTIONS COMPARISION
## TABLE COMPARISION:

| Operation | Standard RISC-V ISA (Hex) | Standard RISC-V ISA (Binary)                              | Hardcoded ISA (Hex) | Hardcoded ISA (Binary)                                |
|-----------|---------------------------|------------------------------------------------------------|---------------------|--------------------------------------------------------|
| ADD       | 32'h00008033                | 000000000010 00001 000 00000 0110011                     | 32'h02208300      | 00000010001000000 100 00000 01100000                  |
| SUB       | 32'h40000033                | 010000000001 00000 000 00010 0110011                     | 32'h02209380      | 00000010001001000 100 10000 01100000                  |
| AND       | 32'h0000f033                | 000000000010 00000 111 00001 0110011                     | 32'h0230a400      | 00000010001101000 101 00100 01100000                  |
| OR        | 32'h0050c333                | 000000000101 00001 110 01000 0110011                     | 32'h02513480      | 00000010010100010 110 10100 01100000                  |
| XOR       | 32'h00408333                | 000000000100 00000 100 01000 0110011                     | 32'h0240c500      | 00000010010000000 100 11000 01100000                  |
| SLT       | 32'h00408033                | 000000000100 00001 010 00000 0110011                     | 32'h02415580      | 00000010010000010 101 01010 01100000                  |
| ADDI      | 32'h00510113                | 000000000101 00010 000 00010 0010011                     | 32'h00520600      | 00000010010000010 010 00010 01100000                  |
| SW        | 32'h00202223                | 000000000010 00000 010 00100 0100011                     | 32'h00209181      | 00000010001000000 010 00001 01100000                  |
| SRL       | 32'h0012d333                | 000000000001 00001 101 00110 0110011                     | 32'h00271803      | 00000010001000000 011 00110 01100000                  |
| BNE       | 32'h01400063                | 000000000000 00000 001 00101 1100011                     | 32'h01409002      |  00000000000000010 001 00100 11000000                  |
| BEQ       | 32'h00f00063                | 000000000000 00000 000 00011 1100011                     | 32'h00f00002      | 00000000000000000 000 00000 11000000                  |
| LW        | 32'h00212283                | 000000000010 00001 010 00011 0000011                     | 32'h00208681      | 00000010001000000 010 01100 01100000                  |
| SLL       | 32'h00109133                | 000000000001 00001 001 00101 0110011                     | 32'h00208783      | 00000010001000000 111 01111 01100000                  |

# TASK 5

## Using above RISC-V Core Verilog netlist and testbench in functional test bench simulation experiment

### We are running this code with gtkwave and icarur

## Identifying Instruction Types
### Given hardcoded instructions are:
![Screenshot 2024-08-11 075657](https://github.com/user-attachments/assets/6d197141-d9a4-441d-ace5-03172e2eb743)

## 1.ADD r6,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 082834](https://github.com/user-attachments/assets/6e7014b7-ef69-4cf4-bd6c-67397bc244d9)


## 2. SUB r7,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 083019](https://github.com/user-attachments/assets/d71d659f-5391-40ac-aec7-2f2c9d97405e)


## 3.AND r8.r1,r3
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084628](https://github.com/user-attachments/assets/d691dd2a-43d8-4990-a62b-cc664986a137)


## 4.OR r9,r2,r5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084710](https://github.com/user-attachments/assets/90538f99-6a2b-4298-9531-89e6e7ac6799)


## 5. XOR r10,r1,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084741](https://github.com/user-attachments/assets/e2090eb6-f21e-4414-b197-2b0474fa0905)


## 6.SLT r1,r2,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084816](https://github.com/user-attachments/assets/65b70148-9075-4c1d-972a-008e43f6c157)


## 7. ADDI r12,r4,5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084857](https://github.com/user-attachments/assets/7006f8f1-523c-40b9-89ca-fa6b4ca7d4c6)


## 8. SW r3,r1,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084929](https://github.com/user-attachments/assets/41241c69-8082-4cb7-9d4e-0f6c14a4ed53)


## 9. LW r13,r01,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085008](https://github.com/user-attachments/assets/25012151-20a2-4f8e-948d-ee1c78177995)


## 10. BEQ r0,r0,15
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085036](https://github.com/user-attachments/assets/aeef1ad0-fa57-4f88-abd0-c94205e6ae5e)


## WAVEFORM OF OUR VERILOG PROGRAM:

### B. Given instructions of our verilog program:

![Screenshot 2024-08-11 183414](https://github.com/user-attachments/assets/5ab5d1be-dea6-4a08-baed-a9d03f67b48c)


## 1.ADD r0,r1,r2
### Operation : 32'h00028233

### Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 192846](https://github.com/user-attachments/assets/bf709913-37ef-405a-8768-46b4a4962813)


## 2.SUB r2,r0,r1
### Operation : 32'h40028033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193033](https://github.com/user-attachments/assets/5316ea1e-558a-4241-95bd-504d9e0f6a7e)



## 3.AND r1,r0,r2
### Operation : 32'h0000f033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193117](https://github.com/user-attachments/assets/678aa3e5-ae6a-47cf-b624-c804c4abc7c1)



## 4.OR r8,r1,r5
### Operation : 32'h0002e433

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193201](https://github.com/user-attachments/assets/db184882-104d-49c3-aac1-1c645f1d8427)



## 5.XOR r8,r0,r4
### Operation : 32'h00029033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193253](https://github.com/user-attachments/assets/9575ff37-fad1-4b5b-aa11-f6b3e543192f)



## 6.SLT r00,r1,r4
### Operation : 32'h0002a033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193335](https://github.com/user-attachments/assets/f9b9d378-fa64-43d0-a701-fcb343df9300)



## 7.ADDI r02,r2,5
### Operation : 32'h0002a013

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193702](https://github.com/user-attachments/assets/2a43e88a-cd76-4626-b2bc-35f7b63c56ce)



## 8.SW r2,r0,4
### Operation : 32'h00008023

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193746](https://github.com/user-attachments/assets/bdabce01-5d47-4ebf-a2b7-a62d0bf288f1)


## 9.SRL r06,r01,r1
### Operation : 32'h0002a033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193829](https://github.com/user-attachments/assets/5df9f65b-61f3-4c29-a8b0-90e27a8d3af9)



## 10.BNE r0,r0,20
### Operation : 32'h00014063

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 194255](https://github.com/user-attachments/assets/152134ba-99cf-4f41-9033-79f86bfff034)




## 11.BEQ r0,r0,15
### Operation : 32'h000c063

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 194945](https://github.com/user-attachments/assets/abd35b41-1a77-4300-b721-bd37b5164080)





## 12.LW r03,r01,2
### Operation : 32'h00010283

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 195401](https://github.com/user-attachments/assets/c4c916a7-76d2-4358-ac4a-cc2af198c399)




## 13.SLL r05,r01,r1
### Operation : 32'h00024033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 195522](https://github.com/user-attachments/assets/add734e3-cf7f-4045-a533-bef34491bdf8)

# Task 5 : Create a C program for Parity checker. Execute same C program in GCC and RISC-V GCC compiler.

## Code for Parity checker
```

#include <stdio.h>

// Function to check the parity of a number
void check_parity(int number) {
    if (number & 1) {
        printf("The number %d has odd parity.\n", number);
    } else {
        printf("The number %d has even parity.\n", number);
    }
}

int main() {
    int number;

    // Prompt the user to enter a number
    printf("Enter an integer: ");
    scanf("%d", &number);

    // Check and print the parity
    check_parity(number);

    return 0;
}
```

## Output for Parity Checker program in from GCC Compiler:

![Screenshot 2024-08-14 102656](https://github.com/user-attachments/assets/4d185a68-c002-4bcb-8b3c-5ecbc558efc3)
![Screenshot 2024-08-14 102900](https://github.com/user-attachments/assets/9eeaa073-1379-4d82-8e91-06a3385d1eb9)
![Screenshot 2024-08-14 102912](https://github.com/user-attachments/assets/0d5dc790-c405-42c0-8b43-182f0742de83)

## Output for the Parity checker from RISC-V GCC compiler(O1 flag):
output of the parity checker C program using RISCV GCC compiler
![Screenshot 2024-08-14 104839](https://github.com/user-attachments/assets/faf8048b-c905-4abe-a22d-5bc81dcec46d)
![Screenshot 2024-08-14 104910](https://github.com/user-attachments/assets/a7445a1c-3dd3-49b9-837b-bb7828c411e0)

## Output for the parity checker from RISC-V GCC compiler(ofast flag):
![Screenshot 2024-08-14 104910](https://github.com/user-attachments/assets/f3e21ac1-fe52-409e-b6df-1ed29f076d0d)


Hence,we got same output for both GCC and RISCV compilers.

## Assembly insturctions for the main function RISC-V compiler using O1 flag:
![Screenshot 2024-08-14 161420](https://github.com/user-attachments/assets/0392e97c-c056-4b45-9eeb-4172df236c2e)


## Assembly instructions for the main function using RISC-V compiler using Ofast Flag:
![Screenshot 2024-08-14 112431](https://github.com/user-attachments/assets/dba7aae2-b8dd-42a8-acf9-a0bd4e3e7962)

# Task 6 : DAY3 Digital Logic with TL-Verilog and Maker chip
 In this particular Task we will use Makerchip where we can design and stimulation of digital ciruits using TL verilog,
 with out installing any additional software.
 
### TL-Verilog:
It is modern hardware description language designed to simplify and accelerate digital design by reducing complicity we were facing in verilog and VHDL.

## STEP1  Building Combinational Circuit for Caluculator in Makerchip:

### Lab on Combinational Logic:
A combinational calculator using TL verilog code on Makerchip.
Screenshot of the implementation of the basic combinational circuit in makerchip.
![Screenshot 2024-08-21 050404](https://github.com/user-attachments/assets/4b5a36dd-f2e7-4cc1-bea3-e6f0acca2af1)

## STEP2  Sequential Logic:

### Sequential Calculator Lab:

Screenshot of the implementation of Sequential Calculator on makerchip.
![Screenshot 2024-08-20 150204](https://github.com/user-attachments/assets/d41e3f10-6190-46f9-bfb2-7ff89506f3d4)

## STEP3  Pipelined Logic:

It is a technique used in digital system design to improve the efficiency of the process by dividing complex tasks into smaller and sequential stages. Every stage performs a specific operation on the data and these stages are arranged in a pipeline. In a pipeline architecture, the processing of an instruction is divided into several stages. This allows for overlapping the execution of multiple instructions, reducing the overall time needed to complete a sequential of tasks.
Hence, circuit can be operated in higher frequencies.

Screen shot shows the implementation of the pipelined logic in makerchip.
![Screenshot 2024-08-21 053824](https://github.com/user-attachments/assets/6be4b738-55a2-40b4-bff2-14e5bc6a0b2f)

## STEP4   Validity:


Validity is used to track the state and timing of transactions within a design description. In TL-verilog transactions are used to represent higher level actions that occur in a design. Validity refers to whether a transaction is considered valid or invalid based on its state.
Validity provides easier debug,cleaner design , error checking , automated clock.

### a) Lab on 2-Cycle calculator with validity:

Below is the screen shot of the 2-cycle calculator with validity:
![Screenshot 2024-08-21 064245](https://github.com/user-attachments/assets/149aeb0c-45c0-450a-8eca-9a69c09bacde)

### b) Lab on 2-Cycle Calculator with Single valued memory:

TL verilog code:
```
 |calc
      @0
         $reset = *reset;
         $clk_nit = *clk;
      @1
         $valid = $reset ? 0 : >>1$valid + 1;
         $valid_or_reset = $valid || $reset; 
   
      ?$valid_or_reset
         @1   
            $val1[31:0] = >>2$out[31:0];
            $val2[31:0] = $rand2[3:0];
            $sel[2:0] = $rand3[2:0];
            
            $sum[31:0] = $val1[31:0] + $val2[31:0];
            $diff[31:0] = $val1[31:0] - $val2[31:0];
            $prod[31:0] = $val1[31:0] * $val2[31:0];
            $quot[31:0] = $val1[31:0] / $val2[31:0];
            
            
         
         @2
            $mem[31:0] = $reset ? '0 : ($sel == 3'd5) ? >>2$out[31:0]
                                                      : >>2$mem[31:0];
            $recall[31:0] = >>2$mem[31:0];                                          
                                                      
            $out[31:0] = $reset ? '0 : ($sel == 3'd0) ? $sum[31:0]
                                     : ($sel == 3'd1) ? $diff[31:0]
                                     : ($sel == 3'd2) ? $prod[31:0]
                                     : ($sel == 3'd3) ? $quot[31:0]
                                     : ($sel == 3'd4) ? $recall[31:0]
                                     : '0;
```
Below is the screenshot of the implementation of code in makerchip
<img width="959" alt="image" src="https://github.com/user-attachments/assets/77f699e4-d3d0-422c-8c3d-6f5b69e3a5a3">


# Task6- DAY4- Basic RISC-V CPU Micro-Architecture:

## Starting point code for RISC-V CPU

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;



      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      //m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```

## STEP1-Fetch

### Program counter

In the stage of fetch CPU fetches the next instruction to be executed from instruction memory, The address where the instruction will be fetched is given by program counter. The program counter is implemented according to the condition,Fetching instruction from the instruction memory is given by
### Code for fetch:

```
|cpu
      @0
         $reset = *reset;
         
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
         
         $imem_rd_en = !$reset ? 1 : 0;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $instr[31:0] = $imem_rd_data[31:0];
```
Value of the PC will be fed as input to instruction memory to be fetched the instruction from particular address location.
Screenshot of implementation of the fetch logic in Makerchip
![Screenshot 2024-08-21 100217](https://github.com/user-attachments/assets/09122cbb-14f5-4621-b6cc-a79010194eb0)

## STEP2- Decode

### a)Lab for Instruction type Decode logic
### b)Lab for Instruction immediate decoding
### c)Lab for Instruction Field Decode logic

 Code for all above decode logics labs
```
         $is_i_instr = $inst[6:2] ==? 5'b0000x ||
                       $inst[6:2] ==? 5'b001x0 ||
                       $inst[6:2] ==? 5'b11001;
                       
         
         $is_u_instr = $inst[6:2] ==? 5'b0x101;
         
         $is_r_instr = $inst[6:2] ==? 5'b01011 ||
                       $inst[6:2] ==? 5'b011x0 ||
                       $inst[6:2] ==? 5'b10100;
         
         $is_b_instr = $inst[6:2] ==? 5'b11000;
         
         $is_j_instr = $inst[6:2] ==? 5'b11011;
         
         $is_s_instr = $inst[6:2] ==? 5'b0100x;
         
         
         $imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
         
         $rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
         $opcode[6:0] = $inst;
         
      
         
    
```

Screenshot for Lab for Instruction type Decode logic ,Lab for Instruction immediate decoding,Lab for Instruction Field Decode logic
![Screenshot 2024-08-21 104357](https://github.com/user-attachments/assets/47a3be92-6156-4f2f-9293-3ba12d634f98)

### d) Lab for decode individual instruction
code for above decode logic
```
 $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
```
## Screen shot of Decode logic
![Screenshot 2024-08-21 105420](https://github.com/user-attachments/assets/8c9736a4-2df0-47f3-a950-5f397b193287)

## STEP3 - RISC-V Control Logic:
### a) Lab for Register Read
Code for the Register read
```
$rf_rd_en1 = $rs1_use;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
```
### b) Lab for ALU operations for add/addi:
code for the above lab
```
$result[31:0] = $is_addi ? $src1_value + $imm :
                $is_add ? $src1_value + $src2_value :
                32'bx ;
```
### c) Lab for Register file write:
code for the above lab
```
 $rf_wr_en = $rd_use;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $rd == 0 ? 0 : $result;
```
Screen shot below shows about  Register read, ALU operation on ADD,ADDI,Register file write
![Screenshot 2024-08-21 203421](https://github.com/user-attachments/assets/09f3ecf1-b8e1-4c9a-8f79-d09432f9e6b0)


### d) Lab for Implementing Branch Instructions:
code for the above lab
```
$taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         $br_tgt_pc[31:0] = $pc + $imm;
```
### e) Lab for creating test bench:
```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
```

### Screen shot for the implementation of the branch logic and overall  STEP 3 RISC-V control logic:
<img width="959" alt="image" src="https://github.com/user-attachments/assets/a8939c66-f851-4f89-ac1d-9d3b7ccf6b52">

# DAY 5 - Complete Pipelined RISC-V CPU micro Architecture:

## STEP-1 Pipelining the CPU:
### Pipelined CPU 
<details>
<summary>
Code for pipelined cpu
</summary>
<pre>

//\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         
      @2
         
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : 1'b0;
         ?$rf_wr_en
            $rf_wr_index[4:0] = $rd[4:0];
         
         $rf_wr_data[31:0] = $result[31:0];
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br);
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

   
</pre>
</details>
<br>

Screen shot of the pipelined cpu
<img width="959" alt="image" src="https://github.com/user-attachments/assets/769b0390-461e-4f6f-9b9a-33c5203846eb">
it took 56 cycles for executing the program from 1to9
<img width="959" alt="image" src="https://github.com/user-attachments/assets/55a12667-61c7-47d4-b4b8-c5d066c9b64b">

## STEP-2 Load and store operations:
<details>
<summary>
Code for load and store operations
</summary>
<pre>
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         
         
      @2
         
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load);
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

</pre>
</details>
<br>

Screenshot of the load and store operations 
![Screenshot 2024-08-21 214639](https://github.com/user-attachments/assets/73d31a45-5d16-4ca9-8be2-4c7d1e02ceaf)

Screen shot of the load and store operations
<img width="959" alt="image" src="https://github.com/user-attachments/assets/3375a910-78b7-47c3-bb7d-c0636fea8f33">

## STEP-3 Completing RISC-V CPU
<details>
<summary>
Code complete RISC-V CPU
</summary>
<pre>

\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc :
                     (>>3$valid_jump && >>3$is_jal) ? >>3$br_tgt_pc :
                     (>>3$valid_jump && >>3$is_jalr) ? >>3$jalr_tgt_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         
         // Branch Target PC
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Jump Target PC
         $jalr_tgt_pc[31:0] = $src1_value + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load || >>1$valid_jump || >>2$valid_jump);
         
         //Jump
         $valid_jump = $valid && $is_jump;
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

</pre>
</details>
<br>

### Screenshot of RISC-V CPU Code,Diagram,waveform,clock signal, reset signal in makerchip:

Final Diagram
<img width="959" alt="image" src="https://github.com/user-attachments/assets/92033d61-7e64-44b9-a231-45aaa3d8eadf">

Clock signal
![Screenshot 2024-08-21 220434](https://github.com/user-attachments/assets/68cc5cdf-3839-4bc1-8842-cefe833e2fdb)

Reset Signal
![Screenshot 2024-08-21 220931](https://github.com/user-attachments/assets/9a28f430-eed8-47ca-9d14-342ae8dea1d0)

![Screenshot 2024-08-21 221320](https://github.com/user-attachments/assets/705a888d-eeb2-40c2-908b-82b7588dafcd)

Hence we can see in the below waveform that in r[14] we can see the sum from 1 to 9

![Screenshot 2024-08-21 221552](https://github.com/user-attachments/assets/288460d2-f8aa-4dec-b1d8-d93b56794be8)

Completed in 58 cycles.



# TASK 7 Converting RISC-V CPU TLV code to Verilog code :

Steps to be followed :
### 1) Installing tools:

Follow the process:

```
python3-pip git iverilog gtkwave

cd ~

sudo apt-get install python3-venv

python3 -m venv .venv

source ~/.venv/bin/activate

pip3 install pyyaml click sandpiper-saas

```
![Screenshot 2024-08-27 061421](https://github.com/user-attachments/assets/c29e0e59-2dd4-4bb2-bfcd-bcd1427c8b88)



### 2)Installing the  required set of commands in virtual environment:

```
 
$ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
$ sudo chmod 666 /var/run/docker.sock
$ cd ~
$ pip3 install pyyaml click sandpiper-saas

```
![Screenshot 2024-08-27 061529](https://github.com/user-attachments/assets/cdc94875-c734-463e-8445-40e4eab06c99)
![Screenshot 2024-08-27 061647](https://github.com/user-attachments/assets/9570eaea-58a6-42be-9fc8-fd7e11d12f3e)





### 3)Cloning Github Repo:

```
git clone https://github.com/manili/VSDBabySoC.git
cd VSDBabySoc
```
![Screenshot 2024-08-27 061938](https://github.com/user-attachments/assets/c134e222-1510-4e27-a04a-29de83ac2e04)




### Step-4:
```
cd /home/vsduser/VSDBabySoC
make pre_synth_sim

```
![Screenshot 2024-08-27 062037](https://github.com/user-attachments/assets/65e00f9b-8df3-4668-a938-b039e4d733f5)


### Steop-5:
Replace the rvmyth.tlv file in VSDBabySoc/src/module folder with RISC-V tlv from maker chip. convert tlv to verilog we will use the code we build in previous lab
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc :
                     (>>3$valid_jump && >>3$is_jal) ? >>3$br_tgt_pc :
                     (>>3$valid_jump && >>3$is_jalr) ? >>3$jalr_tgt_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         
         // Branch Target PC
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Jump Target PC
         $jalr_tgt_pc[31:0] = $src1_value + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load || >>1$valid_jump || >>2$valid_jump);
         
         //Jump
         $valid_jump = $valid && $is_jump;
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

```

### Step7:
```
sandpiper-saas -i ./src/module/rvmyth.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/

```
<img width="926" alt="image" src="https://github.com/user-attachments/assets/2efa6cfc-ef4d-46a2-86b8-900b71fdcf8a">


### Step6 Compiling and Stimulation:

```
iverilog -o output/RV_CPU.out src/module/RV_CPU_tb.v -I src/include -I src/module
cd output
./RV_CPU.out
gtkwave RV_CPU_tb.vcd

```

![Screenshot 2024-08-27 062350](https://github.com/user-attachments/assets/053bb85e-72d4-4186-b0fa-d474f8f23f9a)

## Step8 Results: 
### Makerchip
### GTK wave

Here we will see detail waveforms of clk,reset,10 bit out signals
out from sum of numbers from 1to 9.

Wave form of clk
![Screenshot 2024-08-21 220931](https://github.com/user-attachments/assets/584f53c8-1210-4d3a-8846-33d2e3d8eec7)
waveform of reset
![Screenshot 2024-08-21 221320](https://github.com/user-attachments/assets/9b3431a8-40f3-472e-8b62-91cacdc3e9d8)
10 bit out signals,sum of numbers from 1to 9 
xreg[14] contents
![Screenshot 2024-08-21 221552](https://github.com/user-attachments/assets/75b5912a-c276-4422-8c3f-32e4c1016fbd)

Stimulation of verilog code in gtk wave:
![Screenshot 2024-08-27 073848](https://github.com/user-attachments/assets/68bf0299-e667-45e3-89e2-75491b169237)





Hence,On comparing above waveforms we can tell the result is same for code that stimulated using tlv is same as verilog code.


# TASK 8 - Addition of Peripherals to convert the Digital output to analog output using DAC and PLL:
## Step1 -Tools to be installed:
Installing yosys in linux:
```
    $ git clone https://github.com/YosysHQ/yosys.git
    $ cd yosys
    $ sudo apt install make (If make is not installed) 
    $ sudo apt-get install build-essential clang bison flex \
        libreadline-dev gawk tcl-dev libffi-dev git \
        graphviz xdot pkg-config python3 libboost-system-dev \
        libboost-python-dev libboost-filesystem-dev zlib1g-dev
    $ make config-gcc
    $ make 
    $ sudo make install
```

![Screenshot from 2024-09-03 05-45-57](https://github.com/user-attachments/assets/4d31200b-7591-44f7-938b-d6da6597a883)
Verifying that yosys is installed

### Step2 -Commands used for installing iverilog:
```
    sudo apt-get install iverilog
```
![Screenshot from 2024-09-03 05-46-58](https://github.com/user-attachments/assets/37f20790-4179-4bb6-951f-d1a66d84b337)
Screenshot that iverilog installed

### Step3 -Commands for installtion of gtkwave :
```
    sudo apt update
    sudo apt install gtkwave
```
![Screenshot from 2024-09-03 05-48-13](https://github.com/user-attachments/assets/923c7808-2562-46c7-a90e-94281bd846f8)
![Screenshot from 2024-09-03 05-48-57](https://github.com/user-attachments/assets/f3b4abea-0838-4fcf-a632-b5c7ce841e63)
Screenshot that gtkwave installed in linux

### BabySoC Simulation
### Phase-Locked-Loop (PLL)
### Digital-to-Analog Converter (DAC)

### Step4 -Files required for stimulation of BabySoC:
src/module - contains all RTL files and testbench.v used for simulating our BabySoC design
src/include - contains RTL files used in `include define in main RTL files in src/module
These  files except the RV_CPU.v have been taken from reposatory, https://github.com/Subhasis-Sahu/BabySoC_Simulation

## Step5 -Run Funtional Stimulation:
```

    iverilog -o output/RV_CPU.out src/module/testbench.v -I src/include -I src/module
    ./RV_CPU.out
    gtkwave dump.out
```
The output of the sum 1 to 9 can be observed 
![Screenshot from 2024-09-03 06-03-37](https://github.com/user-attachments/assets/7ed01f2d-8038-4efb-b163-eb4d73d1bfd8)

![Screenshot from 2024-09-02 17-42-27](https://github.com/user-attachments/assets/dadb8716-da27-45d8-8de8-624b8e6eb0f4)




# TASK 9 (DAY 1):
## 1. Introduction of open source simulator iverilog
### Design of RTL:
RTL (Register Transfer Level) design is the process of translating specifications into a functional representation of a digital circuit. It serves as an intermediary between high-level behavioral design and low-level gate-level design. RTL focuses on the data transfer between registers, abstracting away the specifics of gate and transistor implementations. Typically, RTL designs are described using Hardware Description Languages (HDLs) such as Verilog or VHDL.

### Testbench:
A test bench is used to provide stimuli to the design under test (DUT) and verify its functionality as specified in the Verilog description. It is written separately and includes the instantiation of the design that needs to be simulated. The test bench facilitates the validation of the design's performance and behavior.


![Screenshot from 2024-10-22 08-36-35](https://github.com/user-attachments/assets/9ac9588e-d029-421c-bc6b-21f0299911dd)

## Introduction to iverilog and GTKWave
### Iverilog and GTKWAVE:
iverilog is an open-source tool for simulating and synthesizing Verilog designs. It is widely used for the design and verification of digital circuits described in the Verilog hardware description language (HDL).
GTKWave is a widely-used open-source waveform viewer that enables users to visualize and analyze digital signal waveforms generated during circuit simulations. It is often paired with simulation tools like iverilog, providing a graphical representation of signal changes over time within a digital design.
![Screenshot from 2024-10-22 08-43-24](https://github.com/user-attachments/assets/ce57e124-d943-45ac-ae16-0556b9bafc05)

## Introduction to labs:

 Labs using iverilog & gtkwave
Simulation using iverilog simulator good_Mux

Introduction of code:

```
cd asic
mkdir day1
cd day1
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
cd sky130RTLDesignAndSynthesisWorkshop
cd verilog_files

iverilog good_mux.v tb_good_mux.v
./a.out
gtkwave tb_good_mux.vcd

```


Wave form of the Good mux using GTkwave

![Screenshot from 2024-10-22 04-10-45](https://github.com/user-attachments/assets/5e3a9b89-67fb-4560-9db1-dddc6490db2e)

![Screenshot from 2024-10-21 19-06-58](https://github.com/user-attachments/assets/daf93199-bf2d-4e7a-afbf-84ecc63877c5)
###  Introduction to Yosys & Logic Synthesis

Synthesizer is a tool for converting the RTL to Netlist and here we are using the Yosys Synthesizer.
![Screenshot from 2024-10-22 08-54-25](https://github.com/user-attachments/assets/b75249c9-954d-4025-8aa6-7cc0afca672b)
verifying the process



1 RTL design 

![Screenshot from 2024-10-22 08-55-12](https://github.com/user-attachments/assets/c28f9b3f-c6a6-40c8-ade7-13edce5469a8)

2 synthesis
3 Yosys flow
below we can see  the process to be followed:

```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog good_mux.v
synth -top good_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
write_verilog -noattr good_mux_netlist.v

```






![Screenshot from 2024-10-22 04-42-10](https://github.com/user-attachments/assets/95eddf33-0be0-4cd7-90ba-ecabf8a2c916)

![Screenshot from 2024-10-22 04-45-28](https://github.com/user-attachments/assets/64baa11f-1d31-4433-88ae-9fcdd99a47d9)

![Screenshot from 2024-10-22 04-45-51](https://github.com/user-attachments/assets/0d18f9ae-bd61-4207-b629-3ea443b6a59c)

![Screenshot from 2024-10-22 04-47-04](https://github.com/user-attachments/assets/a38a44aa-5c7a-40d3-9540-3109f0e04bce)



![Screenshot from 2024-10-21 19-16-38](https://github.com/user-attachments/assets/da26cb42-c7ba-4637-9e27-290ca1caccb3)


# Day 2 of Labs:
## Introduction to timing labs

navigate to the verilog_files directory then type these below commands

```
Command to open the libary file
$ vim ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
To shut off the background colors/ syntax off:
: syn off
To enable the line numbers
: se nu
```

### Multiple modulues:
SubModules Staistics of Multiple Modules
![Screenshot from 2024-10-22 04-58-15](https://github.com/user-attachments/assets/818f08a4-da7c-4aa7-b187-d17d4b6208fa)

![Screenshot from 2024-10-22 04-59-42](https://github.com/user-attachments/assets/28e9800c-c4ac-4292-9d1b-501160e2d043)



![Screenshot from 2024-10-22 05-00-47](https://github.com/user-attachments/assets/7778662e-a940-408c-99c8-c9bb00ae3539)

![Screenshot from 2024-10-22 05-03-51](https://github.com/user-attachments/assets/4f067d72-92bf-4dfe-ad19-992d319f7a1a)

![Screenshot from 2024-10-22 05-02-09](https://github.com/user-attachments/assets/342b89be-88d3-4a13-8200-a8d32aaa9b3c)
         
![Screenshot from 2024-10-22 05-04-03](https://github.com/user-attachments/assets/934cae73-dac2-41c1-a254-cce94d490494)
![Screenshot from 2024-10-22 05-04-16](https://github.com/user-attachments/assets/e2586d27-9e13-4a79-a1f9-17d513301da2)

### Flat synthesis:
```
_To flatten the netlist
flatten
_Writing the netlist in a crisp manner and to view it
write_verilog -noattr multiple_modules_flat.v
!vim multiple_modules_flat.v
```



![Screenshot from 2024-10-22 05-11-47](https://github.com/user-attachments/assets/f3b20547-2b62-43df-ad6c-cc817d41c205)
![Screenshot from 2024-10-21 19-51-09](https://github.com/user-attachments/assets/3bdc3898-67e9-4004-a0b6-bc307bf00e70)

### Module Level Synthesis

This method is preferred when multiple instances of same module are used. The synthesis is carried out once and is replicate multiple times, and the multiple instances of the same module are stitched together in the top module. This method is helpful when making use of divide and conquer algorithm

```
1. yosys
2. read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
3. read_verilog multiple_modules.v
4. synth -top sub_module1
5. abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
6. show
```

![Screenshot from 2024-10-22 05-19-44](https://github.com/user-attachments/assets/b1e886f5-a459-4f7c-a8b2-bc55ff3fd221)
![Screenshot from 2024-10-22 05-20-08](https://github.com/user-attachments/assets/603dbfd9-c5ed-40d2-ae6e-63fa5964c8ec)
![Screenshot from 2024-10-22 05-20-58](https://github.com/user-attachments/assets/b4ad6f61-e238-4e8e-a491-7ac310e07e4a)
![Screenshot from 2024-10-22 05-21-06](https://github.com/user-attachments/assets/47c0d66c-93a7-44e6-9b57-73e6195f905b)
Above we can seeRealization of the logic 

## Flipflop coding styles and optimization:

In a digital design, when an input signal changes state, the output changes after a propogation delay. All logic gates add some delay to singals. These delays cause expected and unwanted transitions in the output, called as Glitches where the output value is momentarily different from the expected value. An increased delay in one path can cause glitch when those signals are combined at the output gate. In short, more combinational circuits lead to more glitchy outputs that will not settle down with the output value.
Flip flop overview

A D flip-flop is a sequential element that follows the input pin d at the clock's given edge. D flip-flop is a fundamental component in digital logic circuits. There are two types of D Flip-Flops being implemented: Rising-Edge D Flip Flop and Falling-Edge D Flip Flop.

Every flop element needs an initial state, else the combinational circuit will evaluate to a garbage value. In order to achieve this, there are control pins in the flop namely: Set and Reset which can either be Synchronous or Asynchronous.
### Asynchronous Reset/Set:
### Synchronous Reset:

## Flip flop stimulation :
```
Steps Followed for analysing Asynchronous behavior:
//Load the design in iVerilog by giving the verilog and testbench file names
iverilog dff_asyncres.v tb_dff_asyncres.v 
//List so as to ensure that it has been added to the simulator
ls
//To dump the VCD file
./a.out
//To load the VCD file in GTKwaveform
gtkwave tb_dff_asyncres.vcd
```


![Screenshot from 2024-10-22 05-26-04](https://github.com/user-attachments/assets/30cef940-8e89-48a8-a00b-93f7e0c95d99)
![Screenshot from 2024-10-21 19-56-31](https://github.com/user-attachments/assets/2f537777-bdbd-4992-be28-fb72a4f5fa80)

![Screenshot from 2024-10-21 20-01-00](https://github.com/user-attachments/assets/fedcc0c7-527a-4eed-a464-b1c7a65af802)
![Screenshot from 2024-10-21 20-06-08](https://github.com/user-attachments/assets/d4bd0619-1650-44d9-8056-7f68a72914aa)

Above we can see the wave forms of the flipflop stimulation of the Asynchronous set/reset,synchronous reset

## FLIP FLOP SYNTHESIS:
```
_Invoke Yosys
yosys
_Read library 
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Read Design
read_verilog dff_asyncres.v
_Synthesize Design - this controls which module to synthesize
synth -top dff_asyncres
_There will be a separate flop library under a standard library, but here we point back to the same library and tool looks only for DFF instead of all cells
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Generate Netlist
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Realizing Graphical Version of Logic for single modules
show
```



![Screenshot from 2024-10-22 05-34-40](https://github.com/user-attachments/assets/2ff081b4-9ad6-4aee-b24b-a3143e5d5dfc)



![Screenshot from 2024-10-22 05-35-13](https://github.com/user-attachments/assets/1767b70e-5608-4d66-bb76-bd1832658d9f)

![Screenshot from 2024-10-22 05-35-52](https://github.com/user-attachments/assets/c64fb4f4-3342-4d92-be65-d0b231f92b17)

![Screenshot from 2024-10-22 05-36-03](https://github.com/user-attachments/assets/f3300a88-bb77-4e5e-8e2f-a8995a18d7ed)
![Screenshot from 2024-10-22 05-36-16](https://github.com/user-attachments/assets/f719b6ab-16ea-45e7-a9c0-e36086a4f581)
![Screenshot from 2024-10-22 05-39-05](https://github.com/user-attachments/assets/f1553f40-c16a-409c-af71-5976a198297e)
![Screenshot from 2024-10-22 05-39-27](https://github.com/user-attachments/assets/be6464cb-6d8c-4c2f-9014-f48942def403)


![Screenshot from 2024-10-22 05-39-41](https://github.com/user-attachments/assets/544dd974-5e56-4af4-82d4-401ca0a686e8)

![Screenshot from 2024-10-22 05-39-58](https://github.com/user-attachments/assets/7c426f81-93ad-4676-857f-11dfea3cc4ad)
![Screenshot from 2024-10-21 20-29-10](https://github.com/user-attachments/assets/2e42099a-6985-4b0d-9b06-e5630427acd5)

![Screenshot from 2024-10-22 05-43-49](https://github.com/user-attachments/assets/657b5eae-df33-4c02-affe-c6217bdfeb6d)
![Screenshot from 2024-10-22 05-44-46](https://github.com/user-attachments/assets/7d39930c-3932-4bae-b37b-27ba4e682d89)
![Screenshot from 2024-10-21 20-35-00](https://github.com/user-attachments/assets/73b64d40-0616-4000-8e92-e9c721332bf0)


![Screenshot from 2024-10-22 05-47-19](https://github.com/user-attachments/assets/b5576f40-b569-4bcf-a578-4724e2c2296f)
![Screenshot from 2024-10-22 05-48-07](https://github.com/user-attachments/assets/6ee345e9-1a45-4802-904f-6b113ecc4c6e)
![Screenshot from 2024-10-22 05-48-50](https://github.com/user-attachments/assets/4bfb1fba-df21-4763-bf2d-be9baf169407)
![Screenshot from 2024-10-21 20-40-40](https://github.com/user-attachments/assets/646addbf-51b8-4ade-9f08-ab4f2de7ba2f)
![Screenshot from 2024-10-21 20-42-41](https://github.com/user-attachments/assets/6765e84e-827c-4e7a-884a-b37d68d30c8d)


![Screenshot from 2024-10-22 05-52-36](https://github.com/user-attachments/assets/fee5a034-baa2-4801-a433-97888d3bbff9)

![Screenshot from 2024-10-22 05-52-51](https://github.com/user-attachments/assets/a37b648c-b9d9-49d6-b9b2-1a1583333be6)


![Screenshot from 2024-10-21 20-46-00](https://github.com/user-attachments/assets/538b30b9-e520-48b7-b921-25d0bf959228)

![Screenshot from 2024-10-21 20-45-24](https://github.com/user-attachments/assets/6e415b5b-6f0d-4e72-b276-5bcb532a04d5)



![Screenshot from 2024-10-22 06-13-40](https://github.com/user-attachments/assets/90036e0f-0e4f-42aa-a32a-77406dddd85c)


![Screenshot from 2024-10-22 06-14-13](https://github.com/user-attachments/assets/03c68f57-57df-4d50-a246-705572151112)


![Screenshot from 2024-10-22 06-14-19](https://github.com/user-attachments/assets/bb68bb65-13bf-401f-8daa-d193d6d21018)
![Screenshot from 2024-10-22 06-06-31](https://github.com/user-attachments/assets/e62fb048-fe54-4daa-9eb8-260ed540121a)


![Screenshot from 2024-10-22 06-06-49](https://github.com/user-attachments/assets/1e288790-b9a5-4ab6-9d83-e61ab94b8390)

![Screenshot from 2024-10-22 06-06-57](https://github.com/user-attachments/assets/3f26f055-1e80-4ed1-a9af-0f4053026c2f)


![Screenshot from 2024-10-22 06-28-28](https://github.com/user-attachments/assets/0d66dc50-895f-4364-9bce-dc98b8f24672)
![Screenshot from 2024-10-22 06-28-49](https://github.com/user-attachments/assets/a2103769-641c-4b52-a35c-66a9ea4d1ed8)

![Screenshot from 2024-10-22 06-28-54](https://github.com/user-attachments/assets/ad573e38-1bca-4f43-9a5f-27575304524b)


![Screenshot from 2024-10-22 06-29-56](https://github.com/user-attachments/assets/f5cb691a-0aa8-4c6c-85c9-6e846e49be3d)



![Screenshot from 2024-10-22 06-30-08](https://github.com/user-attachments/assets/38010713-70e9-4b33-b242-32bfc975f751)


![Screenshot from 2024-10-22 06-30-22](https://github.com/user-attachments/assets/a3783b47-e4ac-41ad-abeb-3e4a33c2c2b9)


![Screenshot from 2024-10-22 06-41-49](https://github.com/user-attachments/assets/0be84e68-75cb-45dc-b13a-12a5f62ade8a)


![Screenshot from 2024-10-22 06-41-58](https://github.com/user-attachments/assets/7f63704f-e12b-420a-af6e-0691183808fd)



![Screenshot from 2024-10-22 06-55-02](https://github.com/user-attachments/assets/e3e7e6c6-a646-42c2-9aa7-1423f98d6859)


![Screenshot from 2024-10-22 06-55-09](https://github.com/user-attachments/assets/a47a7aff-2ed7-47d3-846b-1766ba47b761)



![Screenshot from 2024-10-22 07-01-25](https://github.com/user-attachments/assets/cff9a6e8-314b-4f34-8564-619c11805c52)


![Screenshot from 2024-10-22 07-01-34](https://github.com/user-attachments/assets/5c3218f1-3e65-48b8-92a0-1418a6a15a6c)
![Screenshot from 2024-10-22 07-01-40](https://github.com/user-attachments/assets/87326eac-2f7c-4618-a627-3bb27b791912)
![Screenshot from 2024-10-22 07-03-33](https://github.com/user-attachments/assets/6a6eb722-8c3c-4249-9750-48898e9eae12)
![Screenshot from 2024-10-22 07-05-02](https://github.com/user-attachments/assets/fad0c3dc-85f8-4327-bd5c-cbb590f8c1ea)
![Screenshot from 2024-10-22 07-05-46](https://github.com/user-attachments/assets/d29f94a0-3402-4992-bce8-f3ff099a4866)
![Screenshot from 2024-10-22 07-06-48](https://github.com/user-attachments/assets/5958d462-ebe4-4e6b-b8e9-1f9c1ec3affd)
![Screenshot from 2024-10-22 07-06-55](https://github.com/user-attachments/assets/b855a02e-b21d-40f4-9c2e-b25a1809160b)
![Screenshot from 2024-10-22 07-07-59](https://github.com/user-attachments/assets/b2c8fd08-5a8d-4f38-abd6-8f29776a330e)
![Screenshot from 2024-10-22 07-08-52](https://github.com/user-attachments/assets/f14d14f5-9fe2-4f6e-82df-8ccc76f9b940)
![Screenshot from 2024-10-22 07-13-16](https://github.com/user-attachments/assets/ad835437-0af4-4386-8d1a-6fa43ec17dab)
![Screenshot from 2024-10-22 07-13-22](https://github.com/user-attachments/assets/9ab7edd5-2f7b-4a14-ba47-4a1f041b1126)
![Screenshot from 2024-10-22 07-13-31](https://github.com/user-attachments/assets/32ab33ec-8db7-4df1-b8e0-02d5a875811d)
![Screenshot from 2024-10-22 07-13-45](https://github.com/user-attachments/assets/1865488f-a236-40aa-8852-47b9245b29fd)
![Screenshot from 2024-10-22 07-13-54](https://github.com/user-attachments/assets/ffe58421-3729-44be-ae17-30601fa7522a)
![Screenshot from 2024-10-22 07-16-59](https://github.com/user-attachments/assets/b4e23d1f-ca38-4a7b-9ac2-859192fa3f08)
![Screenshot from 2024-10-22 07-17-06](https://github.com/user-attachments/assets/6d893683-54e6-4226-a803-9198e731a2f9)
![Screenshot from 2024-10-22 07-17-15](https://github.com/user-attachments/assets/23b63eb3-aa78-40ed-bdb7-a98196f05f89)
![Screenshot from 2024-10-22 07-17-30](https://github.com/user-attachments/assets/6094b1a1-941a-4a0f-b1fe-06dc7167a0c6)
![Screenshot from 2024-10-22 07-17-40](https://github.com/user-attachments/assets/00d26fb4-e5b4-45bd-aa39-b45362973ab5)
![Screenshot from 2024-10-22 07-19-22](https://github.com/user-attachments/assets/65bae535-340f-487b-b2e5-1c5e07ec5f7c)
![Screenshot from 2024-10-22 07-19-27](https://github.com/user-attachments/assets/291b4732-3a69-4903-b359-514c28563733)
![Screenshot from 2024-10-22 07-19-33](https://github.com/user-attachments/assets/f7f3c8f6-795d-40d9-92f1-54eca6f1429f)
![Screenshot from 2024-10-22 07-19-48](https://github.com/user-attachments/assets/4555b683-eb45-4bb2-b7d1-7d0204620034)
![Screenshot from 2024-10-22 07-22-46](https://github.com/user-attachments/assets/2f0847b5-5716-4760-b00a-cceac3842680)


![Screenshot from 2024-10-22 07-29-30](https://github.com/user-attachments/assets/e746ad88-afbb-4c24-8d1c-1f042a45aa0f)
![Screenshot from 2024-10-22 07-29-35](https://github.com/user-attachments/assets/f64f1d1d-95fe-4d86-bc97-8c562f20c0fe)

![Screenshot from 2024-10-22 07-29-54](https://github.com/user-attachments/assets/aea4541a-a92d-40c6-a2e5-5b836d84c8d0)
![Screenshot from 2024-10-22 07-32-48](https://github.com/user-attachments/assets/0f98467a-6d5b-4886-be11-a533765644b5)
![Screenshot from 2024-10-22 07-33-07](https://github.com/user-attachments/assets/9f068176-5550-49d8-910c-139d6bd024d9)
![Screenshot from 2024-10-22 07-39-32](https://github.com/user-attachments/assets/4fea3f82-0074-4df7-bd06-66f3b237f407)
![Screenshot from 2024-10-22 07-36-52](https://github.com/user-attachments/assets/90f72fed-9c86-4e3e-ba0f-bf6bf101e6a9)
![Screenshot from 2024-10-22 07-36-58](https://github.com/user-attachments/assets/0bd506c6-ada7-46c3-9011-11563b722850)
![Screenshot from 2024-10-22 07-37-15](https://github.com/user-attachments/assets/6ba4bae2-bc23-4e6f-85d0-9a3d611f68e9)
![Screenshot from 2024-10-22 07-42-13](https://github.com/user-attachments/assets/5c1feaf4-487f-4233-bdee-6c7c52f43465)
![Screenshot from 2024-10-22 07-42-21](https://github.com/user-attachments/assets/176132b0-4097-45f8-bd91-1abf9b7bac77)
![Screenshot from 2024-10-22 07-55-31](https://github.com/user-attachments/assets/78b233c9-9ccb-482b-9703-779e0648cd49)
![Screenshot from 2024-10-22 07-55-38](https://github.com/user-attachments/assets/f2d11348-5428-4756-abf7-8c5f7ba42e8f)
![Screenshot from 2024-10-22 08-02-24](https://github.com/user-attachments/assets/5a322631-5df2-4e9c-a79c-ad614d18a82d)
![Screenshot from 2024-10-22 08-02-29](https://github.com/user-attachments/assets/5847b16b-063d-4581-8585-9ae7263fcd54)


![Screenshot from 2024-10-22 08-02-35](https://github.com/user-attachments/assets/dae2bd8f-b6dc-4233-8482-783a79cce034)

![Screenshot from 2024-10-22 08-04-21](https://github.com/user-attachments/assets/b8ea4e59-6ab2-482c-b23c-0fc36ca57e3d)
![Screenshot from 2024-10-22 08-07-36](https://github.com/user-attachments/assets/487ba769-712c-4e2b-bebf-40f786f7fed4)

![Screenshot from 2024-10-22 08-07-40](https://github.com/user-attachments/assets/14fe9369-d2f2-4051-b915-339e26cd7702)
![Screenshot from 2024-10-22 08-07-45](https://github.com/user-attachments/assets/e072a1a0-37f3-4b17-a918-dbcf94d5e081)

![Screenshot from 2024-10-22 08-09-56](https://github.com/user-attachments/assets/a2429524-215c-44f7-801a-4ec383f5b757)
![Screenshot from 2024-10-22 08-09-45](https://github.com/user-attachments/assets/1b73c988-c62f-45f0-b815-ffce8792eef1)

![Screenshot from 2024-10-22 08-12-41](https://github.com/user-attachments/assets/03b7014b-bf2e-4a31-98fa-3a2de9ad3c62)
![Screenshot from 2024-10-22 08-12-49](https://github.com/user-attachments/assets/491666f8-c620-44d1-a26b-f84ad5c336c7)
![Screenshot from 2024-10-22 08-13-00](https://github.com/user-attachments/assets/e40e561f-9b7d-4d0a-bd05-42951fa105f6)
![Screenshot from 2024-10-22 08-15-00](https://github.com/user-attachments/assets/ec1ef8f5-1591-47a0-805a-9347390b8a4e)
![Screenshot from 2024-10-22 08-15-06](https://github.com/user-attachments/assets/30865a1c-757d-4f3a-b743-75c1770954dc)


![Screenshot from 2024-10-22 08-15-54](https://github.com/user-attachments/assets/eff43544-edb9-4611-91a8-48c733b7db1e)
![Screenshot from 2024-10-22 08-21-00](https://github.com/user-attachments/assets/1417f7ef-104a-4e20-96f3-54ff570e1969)

![Screenshot from 2024-10-22 08-21-06](https://github.com/user-attachments/assets/b4bc0644-7361-45ca-aa64-45e411d48fea)
![Screenshot from 2024-10-22 08-25-56](https://github.com/user-attachments/assets/089bd66d-4e1e-4a3e-a91c-26b3f20a9f39)

![Screenshot from 2024-10-22 08-26-05](https://github.com/user-attachments/assets/d4cd16f3-6f6e-4941-89d7-24b75436c06a)
![Screenshot from 2024-10-22 08-26-10](https://github.com/user-attachments/assets/40923541-10f8-41d6-a2a2-37306b3ad26d)
![Screenshot from 2024-10-22 08-26-23](https://github.com/user-attachments/assets/8235173d-d7b0-4c3f-9a95-6a6da9af1ace)

![Screenshot from 2024-10-22 08-26-29](https://github.com/user-attachments/assets/630eec1a-7d5d-4f27-a60d-974bae9d12d7)

# Task 10 RISC-V Synthesis for Gate-Level Simulation of BabySoC:

## Synthesis of RISCV Core:

```

yosys
read_liberty -lib sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog rvmyth.v 
read_verilog clk_gate.v 
synth -top rvmyth
abc -liberty sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr rvmyth_netlist.v
show rvmyth
!gedit rvmyth
```
![Screenshot from 2024-10-24 14-14-38](https://github.com/user-attachments/assets/7bb865ec-f173-47fe-bf8c-a2e3ec0867cd)

![Screenshot from 2024-10-24 14-15-55](https://github.com/user-attachments/assets/61fa22ee-13eb-483d-949d-663e1deb2bd5)




![Screenshot from 2024-10-24 05-29-29](https://github.com/user-attachments/assets/9a9037e9-f27d-4783-9bf6-19e20b607702)
![Screenshot from 2024-10-24 05-39-54](https://github.com/user-attachments/assets/92a89998-d052-4d26-843c-95adf40f5168)

![Screenshot from 2024-10-24 05-40-20](https://github.com/user-attachments/assets/3dc34cc0-ff61-4f80-8262-e2094e07a97d)
![Screenshot from 2024-10-24 05-40-45](https://github.com/user-attachments/assets/5f2e153e-bba0-405a-935c-0ba39473e88e)


## Pre Synthesis Simulation:

![Screenshot from 2024-10-24 08-23-40](https://github.com/user-attachments/assets/ddacaa07-d837-4560-ab6c-71a617bcd1eb)

![Screenshot from 2024-10-24 08-25-49](https://github.com/user-attachments/assets/6a44e89f-2719-4a47-a9d5-cd291c5673f7)
pre synthesis output waveform O1
![Screenshot from 2024-10-24 15-04-34](https://github.com/user-attachments/assets/e805c255-8faf-42fb-a9a5-f810f9f9f301)
### pre synthesis outpur waveform with 20 cycles



## BabySoC Post Synthesis Simulation:
### Commands for Gate-Level Simulation:
```
cd BabySoC_Simulation
git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation

```
### Waveform of post synthesis simulation:
```
cd src/module
iverilog -o post_synth.out primitives.v sky130_fd_sc_hd.v testbench.v -D POST_SYNTH_SIM
./post_synth.out
gtkwave post_synth_sim.vcd
```
![Screenshot from 2024-10-24 11-53-00](https://github.com/user-attachments/assets/37250615-a74e-4bbe-9bee-daa956d99e02)
### post synthesis output waveform
![Screenshot from 2024-10-24 11-54-14](https://github.com/user-attachments/assets/410f388a-b43b-4b6b-8cdf-a3b0eec995a5)

### post synthesis output waveform with  20 cycles

![Screenshot from 2024-10-24 12-51-25](https://github.com/user-attachments/assets/af8df2c9-705e-46d9-a42a-959404393067)
![Screenshot from 2024-10-24 15-17-43](https://github.com/user-attachments/assets/dd029461-7b19-4ebd-93af-33abefab7bf3)

Hence the from the above simulations of the waveforms we can find the pre synthesis and the post synthesis are same hence 
O1=O2


# Task 11 Static Timing Analysis on RISCV Core using Custom Clock Time Period of 9.55ns:

## Tools Installation:
```
cd
tar xvfz cudd-3.0.0.tar.gz
cd cudd-3.0.0
./configure
make
```
### Open sta
```
cd
sudo apt-get install cmake clang gcc tcl swig bison flex

git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
cmake -DCUDD_DIR=/home/likith/cudd-3.0.0
make
app/sta
```
![Screenshot from 2024-10-28 20-28-27](https://github.com/user-attachments/assets/b03e8803-3080-49df-9fce-11bb63522aaf)
![Screenshot from 2024-10-28 20-39-51](https://github.com/user-attachments/assets/1cd1ebee-5f35-4260-9ede-c6a48b05f362)


## SDC File Configuration:
```
# Define the clock period
set PERIOD 9.55ns

# Set timing units to nanoseconds (ns)
set_units -time ns

# Create a clock named 'clk' with a period of 9.55nsns, based on the pll/CLK pin
create_clock [get_pins {pll/CLK}] -name clk -period $PERIOD

# Define setup uncertainty as 5% of the clock period
set_clock_uncertainty -setup [expr $PERIOD * 0.05] [get_clocks clk]

# Define clock transition time as 5% of the clock period
set_clock_transition [expr $PERIOD * 0.05] [get_clocks clk]

# Define hold uncertainty as 8% of the clock period
set_clock_uncertainty -hold [expr $PERIOD * 0.08] [get_clocks clk]

# Define input transition times for the specified ports
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_CP]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_VCO]
set_input_transition [expr $PERIOD * 0.08] [get_ports REF]
set_input_transition [expr $PERIOD * 0.08] [get_ports VCO_IN]
set_input_transition [expr $PERIOD * 0.08] [get_ports VREFH]
```

## Timing Analysis:
```
cd VSDBabySoc/src
sta

# Load Liberty files for cell delays and constraints
read_liberty -min ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ./lib/avsdpll.lib
read_liberty -min ./lib/avsddac.lib
read_liberty -max ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ./lib/avsdpll.lib
read_liberty -max ./lib/avsddac.lib

# Load the synthesized Verilog file
read_verilog ../output/synth/vsdbabysoc.synth.v

# Link the design for analysis
link_design vsdbabysoc

# Apply timing constraints from the SDC file
read_sdc ./sdc/vsdbabysoc_synthesis.sdc

# Generate a detailed timing report including min/max delays
report_checks -path_delay min_max -format full_clock_expanded -digits 4
```

## Timing Report:
![Screenshot from 2024-10-28 20-53-26](https://github.com/user-attachments/assets/65e38c98-a702-4e3b-80e9-add989ba4488)
![Screenshot from 2024-10-28 20-53-32](https://github.com/user-attachments/assets/c045e4db-7c0d-4216-8a3e-5f7f8b2fe848)
![Screenshot from 2024-10-28 20-54-01](https://github.com/user-attachments/assets/2d76df19-dc06-4c04-9815-37ffc4f6743b)


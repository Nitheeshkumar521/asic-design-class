# ASIC DESIGN CLASS

## LAB 1 - Create a C program which will caluculate sum from 1 to n, And compile it using GCC compilier

1)- Write a C program in text editor as sum 1 to n  

Following image will show about the image of the C program 

![image1lab1](https://github.com/user-attachments/assets/bdd30330-f82b-488c-ba6f-2216d53d4d38)

2- Compile the code using GCC compiler and run the code to see the output

Image will show about the commands used and output of sum1ton

![image2lab1](https://github.com/user-attachments/assets/c247d982-e748-4ed9-9ed5-bcae0e249202)

## LAB 2 - Compiling Lab1(sum 1 to n) C program with RISCV Compiler

1) We will run lab 1 program using RISCV Gcc compiler


![image1lab2](https://github.com/user-attachments/assets/44bf2daf-6c83-4f52-86ad-afb83a292f7c)

2)In a new tab we will check the assembly code for C program we Run

Here we went to the "main"  when I calculted using calculator got (35)dec and (23)hex 

![img3lab2](https://github.com/user-attachments/assets/d5ab9bb2-d94f-4b70-8e69-0277e7e2aabd)

4) Hence now we will use Ofast on the RISCV compiler and we will use the same C code 
image which describes about the commands


![img5lab2](https://github.com/user-attachments/assets/816cc5e4-374e-4de9-95da-b0ec6eb3158c)

5) We got 12 instructions(byte adressing) in the main section (adress 100bo)

![img6lab2](https://github.com/user-attachments/assets/3a3c8018-28fa-4629-b4c8-d561402dbbbb)

6) RISCV compilation output
 Code Compilation using RISC-V GCC compiler with a different optimization flag (Ofast)
we will compile the code with compiler flag set as -Ofast and then we will check the assembly code again
![lab 2 8](https://github.com/user-attachments/assets/9d590d74-02ef-4005-887b-16107e7326a1)
![lab 2 9](https://github.com/user-attachments/assets/f882ce66-3843-4c09-81e2-ae3fef84b769)

# LAB3-DEBBUGGING WITH SPIKE SIMULATOR AND RUNNING THE OBJECT FILE GENERATED BY RISCV COMPILER IN SPIKE STIMULATOR

1) Debug it in spike using below command and we need our program counter to run till 100b0 by using the below command
   ![lab 3 1](https://github.com/user-attachments/assets/d744c0d1-b465-4ec6-b4a5-02e805546aaf)

2) Next we have to modify the content of a0 below command
press enter then it will run the next instruction is lui a0,0*21
And then we will ger the next instruction as addi sp,sp,-16
![lab 3 3](https://github.com/user-attachments/assets/1f3a1111-bd80-4306-a799-d8f71cb4dbef)


3)As stack pointer content updated by -16. Quit the spike by pressing q 
![lab 3 4](https://github.com/user-attachments/assets/a1440c67-95cf-44d4-a004-9d784f0ac688)

4)And we will follow the steps as follow from step1(Enter the spike stimulation again)
![Screenshot 2024-07-28 131139](https://github.com/user-attachments/assets/ffe17813-aed3-4399-9f54-e1d929df54a2)

Hex value
3ffffffb50-3ffffffb40=10 , 
Dec value
274877905744-274877905728=16

# task 4
## RISC-V Instruction Types and Formats

### R-type: Used for register-register operations.

    Format: funct7 (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)

### I-type: Used for immediate operations.

    Format: imm[11:0] (12 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)
### S-type: Used for store operations.

    Format: imm[11:5] (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:0] (5 bits) | opcode (7 bits)
### B-type: Used for branch operations.

    Format: imm[12] (1 bit) | imm[10:5] (6 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:1] (4 bits) | imm[11] (1 bit) | opcode (7 bits)
### U-type: Used for upper immediate operations.

    Format: imm[31:12] (20 bits) | rd (5 bits) | opcode (7 bits)
### J-type: Used for jump operations.

    Format: imm[20] (1 bit) | imm[10:1] (10 bits) | imm[11] (1 bit) | imm[19:12] (8 bits) | rd (5 bits) | opcode (7 bits)
## Encoded Instructions
### ADD r0, r1, r2

    Type: R
    Encoding: 0000000 00010 00001 000 00000 0110011
    Binary: 00000000001000001000000000110011
### SUB r2, r0, r1

    Type: R
    Encoding: 0100000 00000 00001 000 00010 0110011
    Binary: 01000000000000001000000010110011
### AND r1, r0, r2

    Type: R
    Encoding: 0000000 00010 00000 111 00001 0110011
    Binary: 00000000001000000111000010110011
### OR r8, r1, r5

    Type: R
    Encoding: 0000000 00101 00001 110 01000 0110011
    Binary: 00000000010100001110010000110011
### XOR r8, r0, r4

    Type: R
    Encoding: 0000000 00100 00000 100 01000 0110011
    Binary: 00000000010000000100010000110011
### SLT r0, r1, r4

    Type: R
    Encoding: 0000000 00100 00001 010 00000 0110011
    Binary: 00000000010000001010000000110011
### ADDI r2, r2, 5

    Type: I
    Encoding: 000000000101 00010 000 00010 0010011
    Binary: 00000000010100010000000010010011
### SW r2, r0, 4

    Type: S
    Encoding: 0000000 00010 00000 010 00100 0100011
    Binary: 00000000001000000010001000100011
### SRL r6, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 101 00110 0110011
    Binary: 00000000000100001101000110110011
### BNE r0, r0, 20

    Type: B
    Encoding: 000000 00000 00000 001 01000 1100011
    Binary: 00000000000000000001001000110011
### BEQ r0, r0, 15

    Type: B
    Encoding: 000000 00000 00000 000 01111 1100011
    Binary: 00000000000000000000001111110011
### LW r3, r1, 2

    Type: I
    Encoding: 000000000010 00001 010 00011 0000011
    Binary: 00000000001000001010000011000011
### SLL r5, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 001 00101 0110011
    Binary: 00000000000100001001000101110011

# RISC-V INSTRUCTIONS AND THEIR HEXADECIAMAL REPRESENTATION:

| Instruction       | Type | 32-bit Binary Representation    | Hexadecimal |
|-------------------|------|---------------------------------|-------------|
| `ADD r0, r1, r2`  | R    | `0000000 00010 00001 000 00000 0110011` | `0x00008033` |
| `SUB r2, r0, r1`  | R    | `0100000 00001 00000 000 00010 0110011` | `0x40000033` |
| `AND r1, r0, r2`  | R    | `0000000 00010 00000 111 00001 0110011` | `0x0000F033` |
| `OR r8, r1, r5`   | R    | `0000000 00101 00001 110 01000 0110011` | `0x0050C333` |
| `XOR r8, r0, r4`  | R    | `0000000 00100 00000 100 01000 0110011` | `0x00408333` |
| `SLT r0, r1, r4`  | R    | `0000000 00100 00001 010 00000 0110011` | `0x00408033` |
| `ADDI r2, r2, 5`  | I    | `000000000101 00010 000 00010 0010011` | `0x00510113` |
| `SW r2, r0, 4`    | S    | `0000000 00010 00000 010 00100 0100011` | `0x00202223` |
| `SRL r6, r1, r1`  | R    | `0000000 00001 00001 101 00110 0110011` | `0x0012D333` |
| `BNE r0, r0, 20`  | B    | `000000 00000 00000 001 00101 1100011` | `0x01400063` |
| `BEQ r0, r0, 15`  | B    | `000000 00000 00000 000 00011 1100011` | `0x00F00063` |
| `LW r3, r1, 2`    | I    | `000000000010 00001 010 00011 0000011` | `0x00212283` |
| `SLL r5, r1, r1`  | R    | `0000000 00001 00001 001 00101 0110011` | `0x00109133` |



| Instruction        | Type | 32-bit Instruction Code                        | Binary Representation            | Hexadecimal Representation |
|--------------------|------|------------------------------------------------|----------------------------------|-----------------------------|
| ADD r0, r1, r2  | R    | 0000000 00010 00001 000 00000 0110011       | 00000000001000001000000000110011 | 0x00028233 |
| SUB r2, r0, r1  | R    | 0100000 00001 00000 000 00010 0110011       | 01000000000100000000000000110011 | 0x40028033 |
| AND r1, r0, r2  | R    | 0000000 00010 00000 111 00001 0110011       | 00000000001000000111100000110011 | 0x0000f033 |
| OR r8, r1, r5   | R    | 0000000 00101 00001 110 01000 0110011       | 00000000010100001110010000110011 | 0x0002e433 |
| XOR r8, r0, r4  | R    | 0000000 00100 00000 100 01000 0110011       | 00000000010000000100100000110011 | 0x00029033 |
| SLT r00, r1, r4 | R    | 0000000 00100 00001 010 00000 0110011       | 00000000010000001010000000110011 | 0x0002a033 |
| ADDI r02, r2, 5 | I    | 000000000101 00010 000 00010 0010011       | 0000000001010001000000000010011 | 0x0002a013 |
| SW r2, r0, 4    | S    | 000000000100 00000 010 00010 0100011       | 00000000010000000001000000100011 | 0x00008023 |
| SRL r06, r01, r1| R    | 0000000 00001 00001 101 00110 0110011       | 00000000001000001010100110011001 | 0x0002a033 |
| BNE r0, r0, 20  | B    | 000000000101 00000 001 00000 1100011       | 00000000010100000001000001100011 | 0x00014063 |
| BEQ r0, r0, 15  | B    | 000000000111 00000 000 00000 1100011       | 00000000011100000000000001100011 | 0x0000c063 |
| LW r03, r01, 2  | I    | 000000000010 00001 010 00011 0000011       | 00000000001000001010000010000011 | 0x00010283 |
| SLL r05, r01, r1| R    | 0000000 00001 00001 001 00101 0110011       | 00000000001000001001000100110011 | 0x00024033 |


# RISC-V AND HARDCODED ISA INSTUCTIONS COMPARISION
## TABLE COMPARISION:

| Operation | Standard RISC-V ISA (Hex) | Standard RISC-V ISA (Binary)                              | Hardcoded ISA (Hex) | Hardcoded ISA (Binary)                                |
|-----------|---------------------------|------------------------------------------------------------|---------------------|--------------------------------------------------------|
| ADD       | 32'h00008033                | 000000000010 00001 000 00000 0110011                     | 32'h02208300      | 00000010001000000 100 00000 01100000                  |
| SUB       | 32'h40000033                | 010000000001 00000 000 00010 0110011                     | 32'h02209380      | 00000010001001000 100 10000 01100000                  |
| AND       | 32'h0000f033                | 000000000010 00000 111 00001 0110011                     | 32'h0230a400      | 00000010001101000 101 00100 01100000                  |
| OR        | 32'h0050c333                | 000000000101 00001 110 01000 0110011                     | 32'h02513480      | 00000010010100010 110 10100 01100000                  |
| XOR       | 32'h00408333                | 000000000100 00000 100 01000 0110011                     | 32'h0240c500      | 00000010010000000 100 11000 01100000                  |
| SLT       | 32'h00408033                | 000000000100 00001 010 00000 0110011                     | 32'h02415580      | 00000010010000010 101 01010 01100000                  |
| ADDI      | 32'h00510113                | 000000000101 00010 000 00010 0010011                     | 32'h00520600      | 00000010010000010 010 00010 01100000                  |
| SW        | 32'h00202223                | 000000000010 00000 010 00100 0100011                     | 32'h00209181      | 00000010001000000 010 00001 01100000                  |
| SRL       | 32'h0012d333                | 000000000001 00001 101 00110 0110011                     | 32'h00271803      | 00000010001000000 011 00110 01100000                  |
| BNE       | 32'h01400063                | 000000000000 00000 001 00101 1100011                     | 32'h01409002      |  00000000000000010 001 00100 11000000                  |
| BEQ       | 32'h00f00063                | 000000000000 00000 000 00011 1100011                     | 32'h00f00002      | 00000000000000000 000 00000 11000000                  |
| LW        | 32'h00212283                | 000000000010 00001 010 00011 0000011                     | 32'h00208681      | 00000010001000000 010 01100 01100000                  |
| SLL       | 32'h00109133                | 000000000001 00001 001 00101 0110011                     | 32'h00208783      | 00000010001000000 111 01111 01100000                  |

# TASK 5

## Using above RISC-V Core Verilog netlist and testbench in functional test bench simulation experiment

### We are running this code with gtkwave and icarur

## Identifying Instruction Types
### Given hardcoded instructions are:
![Screenshot 2024-08-11 075657](https://github.com/user-attachments/assets/6d197141-d9a4-441d-ace5-03172e2eb743)

## 1.ADD r6,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 082834](https://github.com/user-attachments/assets/6e7014b7-ef69-4cf4-bd6c-67397bc244d9)


## 2. SUB r7,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 083019](https://github.com/user-attachments/assets/d71d659f-5391-40ac-aec7-2f2c9d97405e)


## 3.AND r8.r1,r3
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084628](https://github.com/user-attachments/assets/d691dd2a-43d8-4990-a62b-cc664986a137)


## 4.OR r9,r2,r5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084710](https://github.com/user-attachments/assets/90538f99-6a2b-4298-9531-89e6e7ac6799)


## 5. XOR r10,r1,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084741](https://github.com/user-attachments/assets/e2090eb6-f21e-4414-b197-2b0474fa0905)


## 6.SLT r1,r2,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084816](https://github.com/user-attachments/assets/65b70148-9075-4c1d-972a-008e43f6c157)


## 7. ADDI r12,r4,5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084857](https://github.com/user-attachments/assets/7006f8f1-523c-40b9-89ca-fa6b4ca7d4c6)


## 8. SW r3,r1,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084929](https://github.com/user-attachments/assets/41241c69-8082-4cb7-9d4e-0f6c14a4ed53)


## 9. LW r13,r01,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085008](https://github.com/user-attachments/assets/25012151-20a2-4f8e-948d-ee1c78177995)


## 10. BEQ r0,r0,15
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085036](https://github.com/user-attachments/assets/aeef1ad0-fa57-4f88-abd0-c94205e6ae5e)


## WAVEFORM OF OUR VERILOG PROGRAM:

### B. Given instructions of our verilog program:

![Screenshot 2024-08-11 183414](https://github.com/user-attachments/assets/5ab5d1be-dea6-4a08-baed-a9d03f67b48c)


## 1.ADD r0,r1,r2
### Operation : 32'h00028233

### Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 192846](https://github.com/user-attachments/assets/bf709913-37ef-405a-8768-46b4a4962813)


## 2.SUB r2,r0,r1
### Operation : 32'h40028033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193033](https://github.com/user-attachments/assets/5316ea1e-558a-4241-95bd-504d9e0f6a7e)



## 3.AND r1,r0,r2
### Operation : 32'h0000f033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193117](https://github.com/user-attachments/assets/678aa3e5-ae6a-47cf-b624-c804c4abc7c1)



## 4.OR r8,r1,r5
### Operation : 32'h0002e433

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193201](https://github.com/user-attachments/assets/db184882-104d-49c3-aac1-1c645f1d8427)



## 5.XOR r8,r0,r4
### Operation : 32'h00029033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193253](https://github.com/user-attachments/assets/9575ff37-fad1-4b5b-aa11-f6b3e543192f)



## 6.SLT r00,r1,r4
### Operation : 32'h0002a033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193335](https://github.com/user-attachments/assets/f9b9d378-fa64-43d0-a701-fcb343df9300)



## 7.ADDI r02,r2,5
### Operation : 32'h0002a013

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193702](https://github.com/user-attachments/assets/2a43e88a-cd76-4626-b2bc-35f7b63c56ce)



## 8.SW r2,r0,4
### Operation : 32'h00008023

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193746](https://github.com/user-attachments/assets/bdabce01-5d47-4ebf-a2b7-a62d0bf288f1)


## 9.SRL r06,r01,r1
### Operation : 32'h0002a033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 193829](https://github.com/user-attachments/assets/5df9f65b-61f3-4c29-a8b0-90e27a8d3af9)



## 10.BNE r0,r0,20
### Operation : 32'h00014063

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 194255](https://github.com/user-attachments/assets/152134ba-99cf-4f41-9033-79f86bfff034)




## 11.BEQ r0,r0,15
### Operation : 32'h000c063

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 194945](https://github.com/user-attachments/assets/abd35b41-1a77-4300-b721-bd37b5164080)





## 12.LW r03,r01,2
### Operation : 32'h00010283

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 195401](https://github.com/user-attachments/assets/c4c916a7-76d2-4358-ac4a-cc2af198c399)




## 13.SLL r05,r01,r1
### Operation : 32'h00024033

###  Waveform of the given hardcopy verilog program:

![Screenshot 2024-08-11 195522](https://github.com/user-attachments/assets/add734e3-cf7f-4045-a533-bef34491bdf8)

# Task 5 : Create a C program for Parity checker. Execute same C program in GCC and RISC-V GCC compiler.

## Code for Parity checker
```

#include <stdio.h>

// Function to check the parity of a number
void check_parity(int number) {
    if (number & 1) {
        printf("The number %d has odd parity.\n", number);
    } else {
        printf("The number %d has even parity.\n", number);
    }
}

int main() {
    int number;

    // Prompt the user to enter a number
    printf("Enter an integer: ");
    scanf("%d", &number);

    // Check and print the parity
    check_parity(number);

    return 0;
}
```

## Output for Parity Checker program in from GCC Compiler:

![Screenshot 2024-08-14 102656](https://github.com/user-attachments/assets/4d185a68-c002-4bcb-8b3c-5ecbc558efc3)
![Screenshot 2024-08-14 102900](https://github.com/user-attachments/assets/9eeaa073-1379-4d82-8e91-06a3385d1eb9)
![Screenshot 2024-08-14 102912](https://github.com/user-attachments/assets/0d5dc790-c405-42c0-8b43-182f0742de83)

## Output for the Parity checker from RISC-V GCC compiler(O1 flag):
output of the parity checker C program using RISCV GCC compiler
![Screenshot 2024-08-14 104839](https://github.com/user-attachments/assets/faf8048b-c905-4abe-a22d-5bc81dcec46d)
![Screenshot 2024-08-14 104910](https://github.com/user-attachments/assets/a7445a1c-3dd3-49b9-837b-bb7828c411e0)

## Output for the parity checker from RISC-V GCC compiler(ofast flag):
![Screenshot 2024-08-14 104910](https://github.com/user-attachments/assets/f3e21ac1-fe52-409e-b6df-1ed29f076d0d)


Hence,we got same output for both GCC and RISCV compilers.

## Assembly insturctions for the main function RISC-V compiler using O1 flag:
![Screenshot 2024-08-14 161420](https://github.com/user-attachments/assets/0392e97c-c056-4b45-9eeb-4172df236c2e)


## Assembly instructions for the main function using RISC-V compiler using Ofast Flag:
![Screenshot 2024-08-14 112431](https://github.com/user-attachments/assets/dba7aae2-b8dd-42a8-acf9-a0bd4e3e7962)

# Task 6 : DAY3 Digital Logic with TL-Verilog and Maker chip
 In this particular Task we will use Makerchip where we can design and stimulation of digital ciruits using TL verilog,
 with out installing any additional software.
 
### TL-Verilog:
It is modern hardware description language designed to simplify and accelerate digital design by reducing complicity we were facing in verilog and VHDL.

## STEP1  Building Combinational Circuit for Caluculator in Makerchip:

### Lab on Combinational Logic:
A combinational calculator using TL verilog code on Makerchip.
Screenshot of the implementation of the basic combinational circuit in makerchip.
![Screenshot 2024-08-21 050404](https://github.com/user-attachments/assets/4b5a36dd-f2e7-4cc1-bea3-e6f0acca2af1)

## STEP2  Sequential Logic:

### Sequential Calculator Lab:

Screenshot of the implementation of Sequential Calculator on makerchip.
![Screenshot 2024-08-20 150204](https://github.com/user-attachments/assets/d41e3f10-6190-46f9-bfb2-7ff89506f3d4)

## STEP3  Pipelined Logic:

It is a technique used in digital system design to improve the efficiency of the process by dividing complex tasks into smaller and sequential stages. Every stage performs a specific operation on the data and these stages are arranged in a pipeline. In a pipeline architecture, the processing of an instruction is divided into several stages. This allows for overlapping the execution of multiple instructions, reducing the overall time needed to complete a sequential of tasks.
Hence, circuit can be operated in higher frequencies.

Screen shot shows the implementation of the pipelined logic in makerchip.
![Screenshot 2024-08-21 053824](https://github.com/user-attachments/assets/6be4b738-55a2-40b4-bff2-14e5bc6a0b2f)

## STEP4   Validity:


Validity is used to track the state and timing of transactions within a design description. In TL-verilog transactions are used to represent higher level actions that occur in a design. Validity refers to whether a transaction is considered valid or invalid based on its state.
Validity provides easier debug,cleaner design , error checking , automated clock.

### a) Lab on 2-Cycle calculator with validity:

Below is the screen shot of the 2-cycle calculator with validity:
![Screenshot 2024-08-21 064245](https://github.com/user-attachments/assets/149aeb0c-45c0-450a-8eca-9a69c09bacde)

### b) Lab on 2-Cycle Calculator with Single valued memory:

TL verilog code:
```
 |calc
      @0
         $reset = *reset;
         $clk_nit = *clk;
      @1
         $valid = $reset ? 0 : >>1$valid + 1;
         $valid_or_reset = $valid || $reset; 
   
      ?$valid_or_reset
         @1   
            $val1[31:0] = >>2$out[31:0];
            $val2[31:0] = $rand2[3:0];
            $sel[2:0] = $rand3[2:0];
            
            $sum[31:0] = $val1[31:0] + $val2[31:0];
            $diff[31:0] = $val1[31:0] - $val2[31:0];
            $prod[31:0] = $val1[31:0] * $val2[31:0];
            $quot[31:0] = $val1[31:0] / $val2[31:0];
            
            
         
         @2
            $mem[31:0] = $reset ? '0 : ($sel == 3'd5) ? >>2$out[31:0]
                                                      : >>2$mem[31:0];
            $recall[31:0] = >>2$mem[31:0];                                          
                                                      
            $out[31:0] = $reset ? '0 : ($sel == 3'd0) ? $sum[31:0]
                                     : ($sel == 3'd1) ? $diff[31:0]
                                     : ($sel == 3'd2) ? $prod[31:0]
                                     : ($sel == 3'd3) ? $quot[31:0]
                                     : ($sel == 3'd4) ? $recall[31:0]
                                     : '0;
```
Below is the screenshot of the implementation of code in makerchip
<img width="959" alt="image" src="https://github.com/user-attachments/assets/77f699e4-d3d0-422c-8c3d-6f5b69e3a5a3">


# Task6- DAY4- Basic RISC-V CPU Micro-Architecture:

## Starting point code for RISC-V CPU

```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;



      // YOUR CODE HERE
      // ...

      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   *passed = *cyc_cnt > 40;
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      //m4+imem(@1)    // Args: (read stage)
      //m4+rf(@1, @1)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)

   //m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule
```

## STEP1-Fetch

### Program counter

In the stage of fetch CPU fetches the next instruction to be executed from instruction memory, The address where the instruction will be fetched is given by program counter. The program counter is implemented according to the condition,Fetching instruction from the instruction memory is given by
### Code for fetch:

```
|cpu
      @0
         $reset = *reset;
         
         $pc[31:0] = $reset ? '0 : >>1$pc + 32'd4;
         
         $imem_rd_en = !$reset ? 1 : 0;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $instr[31:0] = $imem_rd_data[31:0];
```
Value of the PC will be fed as input to instruction memory to be fetched the instruction from particular address location.
Screenshot of implementation of the fetch logic in Makerchip
![Screenshot 2024-08-21 100217](https://github.com/user-attachments/assets/09122cbb-14f5-4621-b6cc-a79010194eb0)

## STEP2- Decode

### a)Lab for Instruction type Decode logic
### b)Lab for Instruction immediate decoding
### c)Lab for Instruction Field Decode logic

 Code for all above decode logics labs
```
         $is_i_instr = $inst[6:2] ==? 5'b0000x ||
                       $inst[6:2] ==? 5'b001x0 ||
                       $inst[6:2] ==? 5'b11001;
                       
         
         $is_u_instr = $inst[6:2] ==? 5'b0x101;
         
         $is_r_instr = $inst[6:2] ==? 5'b01011 ||
                       $inst[6:2] ==? 5'b011x0 ||
                       $inst[6:2] ==? 5'b10100;
         
         $is_b_instr = $inst[6:2] ==? 5'b11000;
         
         $is_j_instr = $inst[6:2] ==? 5'b11011;
         
         $is_s_instr = $inst[6:2] ==? 5'b0100x;
         
         
         $imm[31:0] = $is_i_instr ? {{21{$inst[31]}}, $inst[30:20]} :
                      $is_s_instr ? {{21{$inst[31]}}, $inst[30:25], $inst[11:8], $inst[7]} :
                      $is_b_instr ? {{20{$inst[31]}}, $inst[7], $inst[30:25], $inst[11:8], 1'b0} :
                      $is_u_instr ? {$inst[31], $inst[30:20], $inst[19:12], 12'b0} :
                      $is_j_instr ? {{12{$inst[31]}}, $inst[19:12], $inst[20], $inst[30:21], 1'b0} :
                                    32'b0;
         
         $rs1_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$rs1_use
            $rs1[4:0] = $inst[19:15];
         
         $rs2_use = $is_r_instr || $is_s_instr || $is_b_instr;
         ?$rs2_use
            $rs2[4:0] = $inst[24:20];
            
         $funct3_use = $is_r_instr || $is_i_instr || $is_s_instr || $is_b_instr;
         ?$funct3_use
            $funct3[2:0] = $inst[14:12];
            
         $funct7_use = $is_r_instr ;
         ?$funct7_use
            $funct7[6:0] = $inst[31:25];
            
         $rd_use = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         ?$rd_use
            $rd[4:0] = $inst[11:7];
         
         $opcode[6:0] = $inst;
         
      
         
    
```

Screenshot for Lab for Instruction type Decode logic ,Lab for Instruction immediate decoding,Lab for Instruction Field Decode logic
![Screenshot 2024-08-21 104357](https://github.com/user-attachments/assets/47a3be92-6156-4f2f-9293-3ba12d634f98)

### d) Lab for decode individual instruction
code for above decode logic
```
 $dec_bits [10:0] = {$funct7[5], $funct3, $opcode};
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
```
## Screen shot of Decode logic
![Screenshot 2024-08-21 105420](https://github.com/user-attachments/assets/8c9736a4-2df0-47f3-a950-5f397b193287)

## STEP3 - RISC-V Control Logic:
### a) Lab for Register Read
Code for the Register read
```
$rf_rd_en1 = $rs1_use;
         $rf_rd_index1[4:0] = $rs1;
         $rf_rd_en2 = $rs2_use;
         $rf_rd_index2[4:0] = $rs2;
         
         $src1_value[31:0] = $rf_rd_data1;
         $src2_value[31:0] = $rf_rd_data2;
```
### b) Lab for ALU operations for add/addi:
code for the above lab
```
$result[31:0] = $is_addi ? $src1_value + $imm :
                $is_add ? $src1_value + $src2_value :
                32'bx ;
```
### c) Lab for Register file write:
code for the above lab
```
 $rf_wr_en = $rd_use;
         $rf_wr_index[4:0] = $rd;
         $rf_wr_data[31:0] = $rd == 0 ? 0 : $result;
```
Screen shot below shows about  Register read, ALU operation on ADD,ADDI,Register file write
![Screenshot 2024-08-21 203421](https://github.com/user-attachments/assets/09f3ecf1-b8e1-4c9a-8f79-d09432f9e6b0)


### d) Lab for Implementing Branch Instructions:
code for the above lab
```
$taken_branch = $is_beq ? ($src1_value == $src2_value):
                         $is_bne ? ($src1_value != $src2_value):
                         $is_blt ? (($src1_value < $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bge ? (($src1_value >= $src2_value)^($src1_value[31] != $src2_value[31])):
                         $is_bltu ? ($src1_value < $src2_value):
                         $is_bgeu ? ($src1_value >= $src2_value):
                                    1'b0;
         `BOGUS_USE($taken_branch)
         $br_tgt_pc[31:0] = $pc + $imm;
```
### e) Lab for creating test bench:
```
*passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9) ;
```

### Screen shot for the implementation of the branch logic and overall  STEP 3 RISC-V control logic:
<img width="959" alt="image" src="https://github.com/user-attachments/assets/a8939c66-f851-4f89-ac1d-9d3b7ccf6b52">

# DAY 5 - Complete Pipelined RISC-V CPU micro Architecture:

## STEP-1 Pipelining the CPU:
### Pipelined CPU 
<details>
<summary>
Code for pipelined cpu
</summary>
<pre>

//\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         
      @2
         
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : 1'b0;
         ?$rf_wr_en
            $rf_wr_index[4:0] = $rd[4:0];
         
         $rf_wr_data[31:0] = $result[31:0];
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br);
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[10]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      //m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

   
</pre>
</details>
<br>

Screen shot of the pipelined cpu
<img width="959" alt="image" src="https://github.com/user-attachments/assets/769b0390-461e-4f6f-9b9a-33c5203846eb">
it took 56 cycles for executing the program from 1to9
<img width="959" alt="image" src="https://github.com/user-attachments/assets/55a12667-61c7-47d4-b4b8-c5d066c9b64b">

## STEP-2 Load and store operations:
<details>
<summary>
Code for load and store operations
</summary>
<pre>
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         
         
      @2
         
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load);
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

</pre>
</details>
<br>

Screenshot of the load and store operations 
![Screenshot 2024-08-21 214639](https://github.com/user-attachments/assets/73d31a45-5d16-4ca9-8be2-4c7d1e02ceaf)

Screen shot of the load and store operations
<img width="959" alt="image" src="https://github.com/user-attachments/assets/3375a910-78b7-47c3-bb7d-c0636fea8f33">

## STEP-3 Completing RISC-V CPU
<details>
<summary>
Code complete RISC-V CPU
</summary>
<pre>

\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc :
                     (>>3$valid_jump && >>3$is_jal) ? >>3$br_tgt_pc :
                     (>>3$valid_jump && >>3$is_jalr) ? >>3$jalr_tgt_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         
         // Branch Target PC
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Jump Target PC
         $jalr_tgt_pc[31:0] = $src1_value + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load || >>1$valid_jump || >>2$valid_jump);
         
         //Jump
         $valid_jump = $valid && $is_jump;
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

</pre>
</details>
<br>

### Screenshot of RISC-V CPU Code,Diagram,waveform,clock signal, reset signal in makerchip:

Final Diagram
<img width="959" alt="image" src="https://github.com/user-attachments/assets/92033d61-7e64-44b9-a231-45aaa3d8eadf">

Clock signal
![Screenshot 2024-08-21 220434](https://github.com/user-attachments/assets/68cc5cdf-3839-4bc1-8842-cefe833e2fdb)

Reset Signal
![Screenshot 2024-08-21 220931](https://github.com/user-attachments/assets/9a28f430-eed8-47ca-9d14-342ae8dea1d0)

![Screenshot 2024-08-21 221320](https://github.com/user-attachments/assets/705a888d-eeb2-40c2-908b-82b7588dafcd)

Hence we can see in the below waveform that in r[14] we can see the sum from 1 to 9

![Screenshot 2024-08-21 221552](https://github.com/user-attachments/assets/288460d2-f8aa-4dec-b1d8-d93b56794be8)

Completed in 58 cycles.



# TASK 7 Converting RISC-V CPU TLV code to Verilog code :

Steps to be followed :
### 1) Installing tools:

Follow the process:

```
python3-pip git iverilog gtkwave

cd ~

sudo apt-get install python3-venv

python3 -m venv .venv

source ~/.venv/bin/activate

pip3 install pyyaml click sandpiper-saas

```
![Screenshot 2024-08-27 061421](https://github.com/user-attachments/assets/c29e0e59-2dd4-4bb2-bfcd-bcd1427c8b88)



### 2)Installing the  required set of commands in virtual environment:

```
 
$ sudo apt install make python python3 python3-pip git iverilog gtkwave docker.io
$ sudo chmod 666 /var/run/docker.sock
$ cd ~
$ pip3 install pyyaml click sandpiper-saas

```
![Screenshot 2024-08-27 061529](https://github.com/user-attachments/assets/cdc94875-c734-463e-8445-40e4eab06c99)
![Screenshot 2024-08-27 061647](https://github.com/user-attachments/assets/9570eaea-58a6-42be-9fc8-fd7e11d12f3e)





### 3)Cloning Github Repo:

```
git clone https://github.com/manili/VSDBabySoC.git
cd VSDBabySoc
```
![Screenshot 2024-08-27 061938](https://github.com/user-attachments/assets/c134e222-1510-4e27-a04a-29de83ac2e04)




### Step-4:
```
cd /home/vsduser/VSDBabySoC
make pre_synth_sim

```
![Screenshot 2024-08-27 062037](https://github.com/user-attachments/assets/65e00f9b-8df3-4668-a938-b039e4d733f5)


### Steop-5:
Replace the rvmyth.tlv file in VSDBabySoc/src/module folder with RISC-V tlv from maker chip. convert tlv to verilog we will use the code we build in previous lab
```
\m4_TLV_version 1d: tl-x.org
\SV
   // This code can be found in: https://github.com/stevehoover/RISC-V_MYTH_Workshop
   
   m4_include_lib(['https://raw.githubusercontent.com/BalaDhinesh/RISC-V_MYTH_Workshop/master/tlv_lib/risc-v_shell_lib.tlv'])

\SV
   m4_makerchip_module   // (Expanded in Nav-TLV pane.)
\TLV

   // /====================\
   // | Sum 1 to 9 Program |
   // \====================/
   //
   // Program for MYTH Workshop to test RV32I
   // Add 1,2,3,...,9 (in that order).
   //
   // Regs:
   //  r10 (a0): In: 0, Out: final sum
   //  r12 (a2): 10
   //  r13 (a3): 1..10
   //  r14 (a4): Sum
   // 
   // External to function:
   m4_asm(ADD, r10, r0, r0)             // Initialize r10 (a0) to 0.
   // Function:
   m4_asm(ADD, r14, r10, r0)            // Initialize sum register a4 with 0x0
   m4_asm(ADDI, r12, r10, 1010)         // Store count of 10 in register a2.
   m4_asm(ADD, r13, r10, r0)            // Initialize intermediate sum register a3 with 0
   // Loop:
   m4_asm(ADD, r14, r13, r14)           // Incremental addition
   m4_asm(ADDI, r13, r13, 1)            // Increment intermediate register by 1
   m4_asm(BLT, r13, r12, 1111111111000) // If a3 is less than a2, branch to label named <loop>
   m4_asm(ADD, r10, r14, r0)            // Store final result to register a0 so that it can be read by main program
   m4_asm(SW, r0, r10, 100)
   m4_asm(LW, r15, r0, 100)
   
   // Optional:
   // m4_asm(JAL, r7, 00000000000000000000) // Done. Jump to itself (infinite loop). (Up to 20-bit signed immediate plus implicit 0 bit (unlike JALR) provides byte address; last immediate bit should also be 0)
   m4_define_hier(['M4_IMEM'], M4_NUM_INSTRS)

   |cpu
      @0
         $reset = *reset;
         $clk_nitheesh = *clk;
         $start = >>1$reset ? !$reset ? '1 :'0 :'0;
         //$valid = $reset ? '0 : $start ? '1 : >>3$valid ? '1 : '0;
         
         $pc[31:0] = (>>1$reset) ? '0 :
                     (>>3$valid_taken_br) ? >>3$br_tgt_pc :
                     (>>3$is_load) ? >>3$inc_pc :
                     (>>3$valid_jump && >>3$is_jal) ? >>3$br_tgt_pc :
                     (>>3$valid_jump && >>3$is_jalr) ? >>3$jalr_tgt_pc : >>1$inc_pc;
         
         $imem_rd_en = !$reset;
         $imem_rd_addr[31:0] = $pc[M4_IMEM_INDEX_CNT+1:2];

      @1
         $inc_pc[31:0] = $pc[31:0] + 32'd4;
         $instr[31:0] = $imem_rd_data[31:0];
         
         $is_i_instr = $instr[6:2] ==? 5'b0000x ||
                       $instr[6:2] ==? 5'b001x0 ||
                       $instr[6:2] ==  5'b11001;
         
         $is_r_instr = $instr[6:2] ==  5'b01011 ||
                       $instr[6:2] ==? 5'b011x0 ||
                       $instr[6:2] ==  5'b10100;
         
         $is_s_instr = $instr[6:2] ==? 5'b0100x;
         
         $is_b_instr = $instr[6:2] ==  5'b11000;
         
         $is_j_instr = $instr[6:2] ==  5'b11011;
         
         $is_u_instr = $instr[6:2] ==?  5'b0x101;
         
         $imm[31:0] = $is_i_instr ? {{21{$instr[31]}}, $instr[30:20]} :
                      $is_s_instr ? {{21{$instr[31]}}, $instr[30:25], $instr[11:7]} :
                      $is_b_instr ? {{20{$instr[31]}}, $instr[7], $instr[30:25], $instr[11:8], 1'b0}:
                      $is_u_instr ? {$instr[31:12], 12'b0} :
                      $is_j_instr ? {{12{$instr[31]}}, $instr[19:12], $instr[20], $instr[30:21], 1'b0} :
                      32'b0;
         
         $rs2_valid = $is_r_instr || $is_s_instr || $is_b_instr;
         $rs1_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $rd_valid = $is_r_instr || $is_i_instr || $is_u_instr || $is_j_instr;
         $funct3_valid = $is_r_instr || $is_s_instr || $is_b_instr || $is_i_instr;
         $funct7_valid = $is_r_instr;
         
         ?$rs2_valid
            $rs2[4:0] = $instr[24:20];
         
         ?$rs1_valid
            $rs1[4:0] = $instr[19:15];
         
         ?$rd_valid
            $rd[4:0] = $instr[11:7];
         
         ?$funct3_valid
            $funct3[2:0] = $instr[14:12];
         
         ?$funct7_valid
            $funct7[6:0] = $instr[31:25];
         
         $opcode[6:0] = $instr[6:0];
         
         $dec_bits[10:0] = {$funct7[5],$funct3,$opcode};
         
         // Branch Instruction
         $is_beq = $dec_bits ==? 11'bx_000_1100011;
         $is_bne = $dec_bits ==? 11'bx_001_1100011;
         $is_blt = $dec_bits ==? 11'bx_100_1100011;
         $is_bge = $dec_bits ==? 11'bx_101_1100011;
         $is_bltu = $dec_bits ==? 11'bx_110_1100011;
         $is_bgeu = $dec_bits ==? 11'bx_111_1100011;
         
         // Arithmetic Instruction
         $is_add = $dec_bits ==? 11'b0_000_0110011;
         $is_addi = $dec_bits ==? 11'bx_000_0010011;
         $is_or = $dec_bits ==? 11'b0_110_0110011;
         $is_ori = $dec_bits ==? 11'bx_110_0010011;
         $is_xor = $dec_bits ==? 11'b0_100_0110011;
         $is_xori = $dec_bits ==? 11'bx_100_0010011;
         $is_and = $dec_bits ==? 11'b0_111_0110011;
         $is_andi = $dec_bits ==? 11'bx_111_0010011;
         $is_sub = $dec_bits ==? 11'b1_000_0110011;
         $is_slti = $dec_bits ==? 11'bx_010_0010011;
         $is_sltiu = $dec_bits ==? 11'bx_011_0010011;
         $is_slli = $dec_bits ==? 11'b0_001_0010011;
         $is_srli = $dec_bits ==? 11'b0_101_0010011;
         $is_srai = $dec_bits ==? 11'b1_101_0010011;
         $is_sll = $dec_bits ==? 11'b0_001_0110011;
         $is_slt = $dec_bits ==? 11'b0_010_0110011;
         $is_sltu = $dec_bits ==? 11'b0_011_0110011;
         $is_srl = $dec_bits ==? 11'b0_101_0110011;
         $is_sra = $dec_bits ==? 11'b1_101_0110011;
         
         // Load Instruction
         $is_load = $dec_bits ==? 11'bx_xxx_0000011;
         
         // Store Instruction
         $is_sb = $dec_bits ==? 11'bx_000_0100011;
         $is_sh = $dec_bits ==? 11'bx_001_0100011;
         $is_sw = $dec_bits ==? 11'bx_010_0100011;
         
         // Jump Instruction
         $lui = $dec_bits ==? 11'bx_xxx_0110111;
         $auipc = $dec_bits ==? 11'bx_xxx_0010111;
         $jal = $dec_bits ==? 11'bx_xxx_1101111;
         $jalr = $dec_bits ==? 11'bx_000_1100111;
         
         $is_jump = $is_jal || $is_jalr;
         
      @2
         
         // Branch Target PC
         $br_tgt_pc[31:0] = $pc + $imm;
         
         // Jump Target PC
         $jalr_tgt_pc[31:0] = $src1_value + $imm;
         
         // Register File Read Logic
         $rf_rd_en1 = $rs1_valid;
         ?$rf_rd_en1
            $rf_rd_index1[4:0] = $rs1[4:0];
         
         $rf_rd_en2 = $rs2_valid;
         ?$rf_rd_en2
            $rf_rd_index2[4:0] = $rs2[4:0];
         
         $src1_value[31:0] = ((>>1$rd == $rs1) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data1[31:0];
         $src2_value[31:0] = ((>>1$rd == $rs2) && (>>1$rf_wr_en ==1'b1)) ? >>1$result : $rf_rd_data2[31:0];
         
      @3
         
         //ALU
         $sltu_result = $src1_value < $src2_value ;
         $sltiu_result = $src1_value < $imm ;
         
         $result[31:0] = $is_addi ? $src1_value + $imm :
                         $is_add ? $src1_value + $src2_value :
                         $is_or ? $src1_value | $src2_value :
                         $is_ori ? $src1_value | $imm :
                         $is_xor ? $src1_value ^ $src2_value :
                         $is_xori ? $src1_value ^ $imm :
                         $is_and ? $src1_value & $src2_value :
                         $is_andi ? $src1_value & $imm :
                         $is_sub ? $src1_value - $src2_value :
                         $is_slti ? (($src1_value[31] == $imm[31]) ? $sltiu_result : {31'b0,$src1_value[31]}) :
                         $is_sltiu ? $sltiu_result :
                         $is_slli ? $src1_value << $imm[5:0] :
                         $is_srli ? $src1_value >> $imm[5:0] :
                         $is_srai ? ({{32{$src1_value[31]}}, $src1_value} >> $imm[4:0]) :
                         $is_sll ? $src1_value << $src2_value[4:0] :
                         $is_slt ? (($src1_value[31] == $src2_value[31]) ? $sltu_result : {31'b0,$src1_value[31]}) :
                         $is_sltu ? $sltu_result :
                         $is_srl ? $src1_value >> $src2_value[5:0] :
                         $is_sra ? ({{32{$src1_value[31]}}, $src1_value} >> $src2_value[4:0]) :
                         $lui ? ({$imm[31:12], 12'b0}) :
                         $auipc ? $pc + $imm :
                         $jal ? $pc + 4 :
                         $jalr ? $pc + 4 :
                         ($is_load || $is_s_instr) ? $src1_value + $imm : 32'bx;
         
         // Register File Write
         $rf_wr_en = $valid ? ($rd == 5'b0) ? 1'b0 : $rd_valid : >>2$ld_data;
         ?$rf_wr_en
            $rf_wr_index[4:0] = !$valid ? >>2$rd[4:0] : $rd[4:0];
         
         $rf_wr_data[31:0] = !$valid ? >>2$ld_data[31:0] : $result[31:0];
         
         
         //Branch Instructions
         $taken_br = $is_beq ? ($src1_value == $src2_value) :
                     $is_bne ? ($src1_value != $src2_value) :
                     $is_blt ? (($src1_value < $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bge ? (($src1_value >= $src2_value) ^ ($src1_value[31] != $src2_value[31])) :
                     $is_bltu ? ($src1_value < $src2_value) :
                     $is_bgeu ? ($src1_value >= $src2_value) : 1'b0;
         
         $valid_taken_br = $valid && $taken_br;
         
         // Load
         $valid_load = $valid && $is_load;
         $valid = !(>>1$valid_taken_br || >>2$valid_taken_br || >>1$valid_load || >>2$valid_load || >>1$valid_jump || >>2$valid_jump);
         
         //Jump
         $valid_jump = $valid && $is_jump;
         
      @4
         $dmem_rd_en = $valid_load;
         $dmem_wr_en = $valid && $is_s_instr;
         $dmem_addr[3:0] = $result[5:2];
         $dmem_wr_data[31:0] = $src2_value[31:0];
         
      @5   
         $ld_data[31:0] = $dmem_rd_data[31:0];
         //`BOGUS_USE($is_beq $is_bne $is_blt $is_bge $is_bltu $is_bgeu)
         
      // Note: Because of the magic we are using for visualisation, if visualisation is enabled below,
      //       be sure to avoid having unassigned signals (which you might be using for random inputs)
      //       other than those specifically expected in the labs. You'll get strange errors for these.

   
   // Assert these to end simulation (before Makerchip cycle limit).
   //*passed = *cyc_cnt > 40;
   *passed = |cpu/xreg[15]>>5$value == (1+2+3+4+5+6+7+8+9);
   *failed = 1'b0;
   
   // Macro instantiations for:
   //  o instruction memory
   //  o register file
   //  o data memory
   //  o CPU visualization
   |cpu
      m4+imem(@1)    // Args: (read stage)
      m4+rf(@2, @3)  // Args: (read stage, write stage) - if equal, no register bypass is required
      m4+dmem(@4)    // Args: (read/write stage)
   m4+cpu_viz(@4)    // For visualisation, argument should be at least equal to the last stage of CPU logic. @4 would work for all labs.
\SV
   endmodule

```

### Step7:
```
sandpiper-saas -i ./src/module/rvmyth.tlv -o rvmyth.v --bestsv --noline -p verilog --outdir ./src/module/

```
<img width="926" alt="image" src="https://github.com/user-attachments/assets/2efa6cfc-ef4d-46a2-86b8-900b71fdcf8a">


### Step6 Compiling and Stimulation:

```
iverilog -o output/RV_CPU.out src/module/RV_CPU_tb.v -I src/include -I src/module
cd output
./RV_CPU.out
gtkwave RV_CPU_tb.vcd

```

![Screenshot 2024-08-27 062350](https://github.com/user-attachments/assets/053bb85e-72d4-4186-b0fa-d474f8f23f9a)

## Step8 Results: 
### Makerchip
### GTK wave

Here we will see detail waveforms of clk,reset,10 bit out signals
out from sum of numbers from 1to 9.

Wave form of clk
![Screenshot 2024-08-21 220931](https://github.com/user-attachments/assets/584f53c8-1210-4d3a-8846-33d2e3d8eec7)
waveform of reset
![Screenshot 2024-08-21 221320](https://github.com/user-attachments/assets/9b3431a8-40f3-472e-8b62-91cacdc3e9d8)
10 bit out signals,sum of numbers from 1to 9 
xreg[14] contents
![Screenshot 2024-08-21 221552](https://github.com/user-attachments/assets/75b5912a-c276-4422-8c3f-32e4c1016fbd)

Stimulation of verilog code in gtk wave:
![Screenshot 2024-08-27 073848](https://github.com/user-attachments/assets/68bf0299-e667-45e3-89e2-75491b169237)





Hence,On comparing above waveforms we can tell the result is same for code that stimulated using tlv is same as verilog code.


# TASK 8 - Addition of Peripherals to convert the Digital output to analog output using DAC and PLL:
## Step1 -Tools to be installed:
Installing yosys in linux:
```
    $ git clone https://github.com/YosysHQ/yosys.git
    $ cd yosys
    $ sudo apt install make (If make is not installed) 
    $ sudo apt-get install build-essential clang bison flex \
        libreadline-dev gawk tcl-dev libffi-dev git \
        graphviz xdot pkg-config python3 libboost-system-dev \
        libboost-python-dev libboost-filesystem-dev zlib1g-dev
    $ make config-gcc
    $ make 
    $ sudo make install
```

![Screenshot from 2024-09-03 05-45-57](https://github.com/user-attachments/assets/4d31200b-7591-44f7-938b-d6da6597a883)
Verifying that yosys is installed

### Step2 -Commands used for installing iverilog:
```
    sudo apt-get install iverilog
```
![Screenshot from 2024-09-03 05-46-58](https://github.com/user-attachments/assets/37f20790-4179-4bb6-951f-d1a66d84b337)
Screenshot that iverilog installed

### Step3 -Commands for installtion of gtkwave :
```
    sudo apt update
    sudo apt install gtkwave
```
![Screenshot from 2024-09-03 05-48-13](https://github.com/user-attachments/assets/923c7808-2562-46c7-a90e-94281bd846f8)
![Screenshot from 2024-09-03 05-48-57](https://github.com/user-attachments/assets/f3b4abea-0838-4fcf-a632-b5c7ce841e63)
Screenshot that gtkwave installed in linux

### BabySoC Simulation
### Phase-Locked-Loop (PLL)
### Digital-to-Analog Converter (DAC)

### Step4 -Files required for stimulation of BabySoC:
src/module - contains all RTL files and testbench.v used for simulating our BabySoC design
src/include - contains RTL files used in `include define in main RTL files in src/module
These  files except the RV_CPU.v have been taken from reposatory, https://github.com/Subhasis-Sahu/BabySoC_Simulation

## Step5 -Run Funtional Stimulation:
```

    iverilog -o output/RV_CPU.out src/module/testbench.v -I src/include -I src/module
    ./RV_CPU.out
    gtkwave dump.out
```
The output of the sum 1 to 9 can be observed 
![Screenshot from 2024-09-03 06-03-37](https://github.com/user-attachments/assets/7ed01f2d-8038-4efb-b163-eb4d73d1bfd8)

![Screenshot from 2024-09-02 17-42-27](https://github.com/user-attachments/assets/dadb8716-da27-45d8-8de8-624b8e6eb0f4)




# TASK 9 (DAY 1):
## 1. Introduction of open source simulator iverilog
### Design of RTL:
RTL (Register Transfer Level) design is the process of translating specifications into a functional representation of a digital circuit. It serves as an intermediary between high-level behavioral design and low-level gate-level design. RTL focuses on the data transfer between registers, abstracting away the specifics of gate and transistor implementations. Typically, RTL designs are described using Hardware Description Languages (HDLs) such as Verilog or VHDL.

### Testbench:
A test bench is used to provide stimuli to the design under test (DUT) and verify its functionality as specified in the Verilog description. It is written separately and includes the instantiation of the design that needs to be simulated. The test bench facilitates the validation of the design's performance and behavior.


![Screenshot from 2024-10-22 08-36-35](https://github.com/user-attachments/assets/9ac9588e-d029-421c-bc6b-21f0299911dd)

## Introduction to iverilog and GTKWave
### Iverilog and GTKWAVE:
iverilog is an open-source tool for simulating and synthesizing Verilog designs. It is widely used for the design and verification of digital circuits described in the Verilog hardware description language (HDL).
GTKWave is a widely-used open-source waveform viewer that enables users to visualize and analyze digital signal waveforms generated during circuit simulations. It is often paired with simulation tools like iverilog, providing a graphical representation of signal changes over time within a digital design.
![Screenshot from 2024-10-22 08-43-24](https://github.com/user-attachments/assets/ce57e124-d943-45ac-ae16-0556b9bafc05)

## Introduction to labs:

 Labs using iverilog & gtkwave
Simulation using iverilog simulator good_Mux

Introduction of code:

```
cd asic
mkdir day1
cd day1
git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop.git
cd sky130RTLDesignAndSynthesisWorkshop
cd verilog_files

iverilog good_mux.v tb_good_mux.v
./a.out
gtkwave tb_good_mux.vcd

```


Wave form of the Good mux using GTkwave

![Screenshot from 2024-10-22 04-10-45](https://github.com/user-attachments/assets/5e3a9b89-67fb-4560-9db1-dddc6490db2e)

![Screenshot from 2024-10-21 19-06-58](https://github.com/user-attachments/assets/daf93199-bf2d-4e7a-afbf-84ecc63877c5)
###  Introduction to Yosys & Logic Synthesis

Synthesizer is a tool for converting the RTL to Netlist and here we are using the Yosys Synthesizer.
![Screenshot from 2024-10-22 08-54-25](https://github.com/user-attachments/assets/b75249c9-954d-4025-8aa6-7cc0afca672b)
verifying the process



1 RTL design 

![Screenshot from 2024-10-22 08-55-12](https://github.com/user-attachments/assets/c28f9b3f-c6a6-40c8-ade7-13edce5469a8)

2 synthesis
3 Yosys flow
below we can see  the process to be followed:

```
yosys
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog good_mux.v
synth -top good_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
write_verilog -noattr good_mux_netlist.v

```






![Screenshot from 2024-10-22 04-42-10](https://github.com/user-attachments/assets/95eddf33-0be0-4cd7-90ba-ecabf8a2c916)

![Screenshot from 2024-10-22 04-45-28](https://github.com/user-attachments/assets/64baa11f-1d31-4433-88ae-9fcdd99a47d9)

![Screenshot from 2024-10-22 04-45-51](https://github.com/user-attachments/assets/0d18f9ae-bd61-4207-b629-3ea443b6a59c)

![Screenshot from 2024-10-22 04-47-04](https://github.com/user-attachments/assets/a38a44aa-5c7a-40d3-9540-3109f0e04bce)



![Screenshot from 2024-10-21 19-16-38](https://github.com/user-attachments/assets/da26cb42-c7ba-4637-9e27-290ca1caccb3)


# Day 2 of Labs:
## Introduction to timing labs

navigate to the verilog_files directory then type these below commands

```
Command to open the libary file
$ vim ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
To shut off the background colors/ syntax off:
: syn off
To enable the line numbers
: se nu
```

### Multiple modulues:
SubModules Staistics of Multiple Modules
![Screenshot from 2024-10-22 04-58-15](https://github.com/user-attachments/assets/818f08a4-da7c-4aa7-b187-d17d4b6208fa)

![Screenshot from 2024-10-22 04-59-42](https://github.com/user-attachments/assets/28e9800c-c4ac-4292-9d1b-501160e2d043)



![Screenshot from 2024-10-22 05-00-47](https://github.com/user-attachments/assets/7778662e-a940-408c-99c8-c9bb00ae3539)

![Screenshot from 2024-10-22 05-03-51](https://github.com/user-attachments/assets/4f067d72-92bf-4dfe-ad19-992d319f7a1a)

![Screenshot from 2024-10-22 05-02-09](https://github.com/user-attachments/assets/342b89be-88d3-4a13-8200-a8d32aaa9b3c)
         
![Screenshot from 2024-10-22 05-04-03](https://github.com/user-attachments/assets/934cae73-dac2-41c1-a254-cce94d490494)
![Screenshot from 2024-10-22 05-04-16](https://github.com/user-attachments/assets/e2586d27-9e13-4a79-a1f9-17d513301da2)

### Flat synthesis:
```
_To flatten the netlist
flatten
_Writing the netlist in a crisp manner and to view it
write_verilog -noattr multiple_modules_flat.v
!vim multiple_modules_flat.v
```



![Screenshot from 2024-10-22 05-11-47](https://github.com/user-attachments/assets/f3b20547-2b62-43df-ad6c-cc817d41c205)
![Screenshot from 2024-10-21 19-51-09](https://github.com/user-attachments/assets/3bdc3898-67e9-4004-a0b6-bc307bf00e70)

### Module Level Synthesis

This method is preferred when multiple instances of same module are used. The synthesis is carried out once and is replicate multiple times, and the multiple instances of the same module are stitched together in the top module. This method is helpful when making use of divide and conquer algorithm

```
1. yosys
2. read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
3. read_verilog multiple_modules.v
4. synth -top sub_module1
5. abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
6. show
```

![Screenshot from 2024-10-22 05-19-44](https://github.com/user-attachments/assets/b1e886f5-a459-4f7c-a8b2-bc55ff3fd221)
![Screenshot from 2024-10-22 05-20-08](https://github.com/user-attachments/assets/603dbfd9-c5ed-40d2-ae6e-63fa5964c8ec)
![Screenshot from 2024-10-22 05-20-58](https://github.com/user-attachments/assets/b4ad6f61-e238-4e8e-a491-7ac310e07e4a)
![Screenshot from 2024-10-22 05-21-06](https://github.com/user-attachments/assets/47c0d66c-93a7-44e6-9b57-73e6195f905b)
Above we can seeRealization of the logic 

## Flipflop coding styles and optimization:

In a digital design, when an input signal changes state, the output changes after a propogation delay. All logic gates add some delay to singals. These delays cause expected and unwanted transitions in the output, called as Glitches where the output value is momentarily different from the expected value. An increased delay in one path can cause glitch when those signals are combined at the output gate. In short, more combinational circuits lead to more glitchy outputs that will not settle down with the output value.
Flip flop overview

A D flip-flop is a sequential element that follows the input pin d at the clock's given edge. D flip-flop is a fundamental component in digital logic circuits. There are two types of D Flip-Flops being implemented: Rising-Edge D Flip Flop and Falling-Edge D Flip Flop.

Every flop element needs an initial state, else the combinational circuit will evaluate to a garbage value. In order to achieve this, there are control pins in the flop namely: Set and Reset which can either be Synchronous or Asynchronous.
### Asynchronous Reset/Set:
### Synchronous Reset:

## Flip flop stimulation :
```
Steps Followed for analysing Asynchronous behavior:
//Load the design in iVerilog by giving the verilog and testbench file names
iverilog dff_asyncres.v tb_dff_asyncres.v 
//List so as to ensure that it has been added to the simulator
ls
//To dump the VCD file
./a.out
//To load the VCD file in GTKwaveform
gtkwave tb_dff_asyncres.vcd
```


![Screenshot from 2024-10-22 05-26-04](https://github.com/user-attachments/assets/30cef940-8e89-48a8-a00b-93f7e0c95d99)
![Screenshot from 2024-10-21 19-56-31](https://github.com/user-attachments/assets/2f537777-bdbd-4992-be28-fb72a4f5fa80)

![Screenshot from 2024-10-21 20-01-00](https://github.com/user-attachments/assets/fedcc0c7-527a-4eed-a464-b1c7a65af802)
![Screenshot from 2024-10-21 20-06-08](https://github.com/user-attachments/assets/d4bd0619-1650-44d9-8056-7f68a72914aa)

Above we can see the wave forms of the flipflop stimulation of the Asynchronous set/reset,synchronous reset

## FLIP FLOP SYNTHESIS:
```
_Invoke Yosys
yosys
_Read library 
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Read Design
read_verilog dff_asyncres.v
_Synthesize Design - this controls which module to synthesize
synth -top dff_asyncres
_There will be a separate flop library under a standard library, but here we point back to the same library and tool looks only for DFF instead of all cells
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Generate Netlist
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
_Realizing Graphical Version of Logic for single modules
show
```



![Screenshot from 2024-10-22 05-34-40](https://github.com/user-attachments/assets/2ff081b4-9ad6-4aee-b24b-a3143e5d5dfc)



![Screenshot from 2024-10-22 05-35-13](https://github.com/user-attachments/assets/1767b70e-5608-4d66-bb76-bd1832658d9f)

![Screenshot from 2024-10-22 05-35-52](https://github.com/user-attachments/assets/c64fb4f4-3342-4d92-be65-d0b231f92b17)

![Screenshot from 2024-10-22 05-36-03](https://github.com/user-attachments/assets/f3300a88-bb77-4e5e-8e2f-a8995a18d7ed)
![Screenshot from 2024-10-22 05-36-16](https://github.com/user-attachments/assets/f719b6ab-16ea-45e7-a9c0-e36086a4f581)
![Screenshot from 2024-10-22 05-39-05](https://github.com/user-attachments/assets/f1553f40-c16a-409c-af71-5976a198297e)
![Screenshot from 2024-10-22 05-39-27](https://github.com/user-attachments/assets/be6464cb-6d8c-4c2f-9014-f48942def403)


![Screenshot from 2024-10-22 05-39-41](https://github.com/user-attachments/assets/544dd974-5e56-4af4-82d4-401ca0a686e8)

![Screenshot from 2024-10-22 05-39-58](https://github.com/user-attachments/assets/7c426f81-93ad-4676-857f-11dfea3cc4ad)
![Screenshot from 2024-10-21 20-29-10](https://github.com/user-attachments/assets/2e42099a-6985-4b0d-9b06-e5630427acd5)

![Screenshot from 2024-10-22 05-43-49](https://github.com/user-attachments/assets/657b5eae-df33-4c02-affe-c6217bdfeb6d)
![Screenshot from 2024-10-22 05-44-46](https://github.com/user-attachments/assets/7d39930c-3932-4bae-b37b-27ba4e682d89)
![Screenshot from 2024-10-21 20-35-00](https://github.com/user-attachments/assets/73b64d40-0616-4000-8e92-e9c721332bf0)


![Screenshot from 2024-10-22 05-47-19](https://github.com/user-attachments/assets/b5576f40-b569-4bcf-a578-4724e2c2296f)
![Screenshot from 2024-10-22 05-48-07](https://github.com/user-attachments/assets/6ee345e9-1a45-4802-904f-6b113ecc4c6e)
![Screenshot from 2024-10-22 05-48-50](https://github.com/user-attachments/assets/4bfb1fba-df21-4763-bf2d-be9baf169407)
![Screenshot from 2024-10-21 20-40-40](https://github.com/user-attachments/assets/646addbf-51b8-4ade-9f08-ab4f2de7ba2f)
![Screenshot from 2024-10-21 20-42-41](https://github.com/user-attachments/assets/6765e84e-827c-4e7a-884a-b37d68d30c8d)


![Screenshot from 2024-10-22 05-52-36](https://github.com/user-attachments/assets/fee5a034-baa2-4801-a433-97888d3bbff9)

![Screenshot from 2024-10-22 05-52-51](https://github.com/user-attachments/assets/a37b648c-b9d9-49d6-b9b2-1a1583333be6)


![Screenshot from 2024-10-21 20-46-00](https://github.com/user-attachments/assets/538b30b9-e520-48b7-b921-25d0bf959228)

![Screenshot from 2024-10-21 20-45-24](https://github.com/user-attachments/assets/6e415b5b-6f0d-4e72-b276-5bcb532a04d5)



![Screenshot from 2024-10-22 06-13-40](https://github.com/user-attachments/assets/90036e0f-0e4f-42aa-a32a-77406dddd85c)


![Screenshot from 2024-10-22 06-14-13](https://github.com/user-attachments/assets/03c68f57-57df-4d50-a246-705572151112)


![Screenshot from 2024-10-22 06-14-19](https://github.com/user-attachments/assets/bb68bb65-13bf-401f-8daa-d193d6d21018)
![Screenshot from 2024-10-22 06-06-31](https://github.com/user-attachments/assets/e62fb048-fe54-4daa-9eb8-260ed540121a)


![Screenshot from 2024-10-22 06-06-49](https://github.com/user-attachments/assets/1e288790-b9a5-4ab6-9d83-e61ab94b8390)

![Screenshot from 2024-10-22 06-06-57](https://github.com/user-attachments/assets/3f26f055-1e80-4ed1-a9af-0f4053026c2f)


![Screenshot from 2024-10-22 06-28-28](https://github.com/user-attachments/assets/0d66dc50-895f-4364-9bce-dc98b8f24672)
![Screenshot from 2024-10-22 06-28-49](https://github.com/user-attachments/assets/a2103769-641c-4b52-a35c-66a9ea4d1ed8)

![Screenshot from 2024-10-22 06-28-54](https://github.com/user-attachments/assets/ad573e38-1bca-4f43-9a5f-27575304524b)


![Screenshot from 2024-10-22 06-29-56](https://github.com/user-attachments/assets/f5cb691a-0aa8-4c6c-85c9-6e846e49be3d)



![Screenshot from 2024-10-22 06-30-08](https://github.com/user-attachments/assets/38010713-70e9-4b33-b242-32bfc975f751)


![Screenshot from 2024-10-22 06-30-22](https://github.com/user-attachments/assets/a3783b47-e4ac-41ad-abeb-3e4a33c2c2b9)


![Screenshot from 2024-10-22 06-41-49](https://github.com/user-attachments/assets/0be84e68-75cb-45dc-b13a-12a5f62ade8a)


![Screenshot from 2024-10-22 06-41-58](https://github.com/user-attachments/assets/7f63704f-e12b-420a-af6e-0691183808fd)



![Screenshot from 2024-10-22 06-55-02](https://github.com/user-attachments/assets/e3e7e6c6-a646-42c2-9aa7-1423f98d6859)


![Screenshot from 2024-10-22 06-55-09](https://github.com/user-attachments/assets/a47a7aff-2ed7-47d3-846b-1766ba47b761)



![Screenshot from 2024-10-22 07-01-25](https://github.com/user-attachments/assets/cff9a6e8-314b-4f34-8564-619c11805c52)


![Screenshot from 2024-10-22 07-01-34](https://github.com/user-attachments/assets/5c3218f1-3e65-48b8-92a0-1418a6a15a6c)
![Screenshot from 2024-10-22 07-01-40](https://github.com/user-attachments/assets/87326eac-2f7c-4618-a627-3bb27b791912)
![Screenshot from 2024-10-22 07-03-33](https://github.com/user-attachments/assets/6a6eb722-8c3c-4249-9750-48898e9eae12)
![Screenshot from 2024-10-22 07-05-02](https://github.com/user-attachments/assets/fad0c3dc-85f8-4327-bd5c-cbb590f8c1ea)
![Screenshot from 2024-10-22 07-05-46](https://github.com/user-attachments/assets/d29f94a0-3402-4992-bce8-f3ff099a4866)
![Screenshot from 2024-10-22 07-06-48](https://github.com/user-attachments/assets/5958d462-ebe4-4e6b-b8e9-1f9c1ec3affd)
![Screenshot from 2024-10-22 07-06-55](https://github.com/user-attachments/assets/b855a02e-b21d-40f4-9c2e-b25a1809160b)
![Screenshot from 2024-10-22 07-07-59](https://github.com/user-attachments/assets/b2c8fd08-5a8d-4f38-abd6-8f29776a330e)
![Screenshot from 2024-10-22 07-08-52](https://github.com/user-attachments/assets/f14d14f5-9fe2-4f6e-82df-8ccc76f9b940)
![Screenshot from 2024-10-22 07-13-16](https://github.com/user-attachments/assets/ad835437-0af4-4386-8d1a-6fa43ec17dab)
![Screenshot from 2024-10-22 07-13-22](https://github.com/user-attachments/assets/9ab7edd5-2f7b-4a14-ba47-4a1f041b1126)
![Screenshot from 2024-10-22 07-13-31](https://github.com/user-attachments/assets/32ab33ec-8db7-4df1-b8e0-02d5a875811d)
![Screenshot from 2024-10-22 07-13-45](https://github.com/user-attachments/assets/1865488f-a236-40aa-8852-47b9245b29fd)
![Screenshot from 2024-10-22 07-13-54](https://github.com/user-attachments/assets/ffe58421-3729-44be-ae17-30601fa7522a)
![Screenshot from 2024-10-22 07-16-59](https://github.com/user-attachments/assets/b4e23d1f-ca38-4a7b-9ac2-859192fa3f08)
![Screenshot from 2024-10-22 07-17-06](https://github.com/user-attachments/assets/6d893683-54e6-4226-a803-9198e731a2f9)
![Screenshot from 2024-10-22 07-17-15](https://github.com/user-attachments/assets/23b63eb3-aa78-40ed-bdb7-a98196f05f89)
![Screenshot from 2024-10-22 07-17-30](https://github.com/user-attachments/assets/6094b1a1-941a-4a0f-b1fe-06dc7167a0c6)
![Screenshot from 2024-10-22 07-17-40](https://github.com/user-attachments/assets/00d26fb4-e5b4-45bd-aa39-b45362973ab5)
![Screenshot from 2024-10-22 07-19-22](https://github.com/user-attachments/assets/65bae535-340f-487b-b2e5-1c5e07ec5f7c)
![Screenshot from 2024-10-22 07-19-27](https://github.com/user-attachments/assets/291b4732-3a69-4903-b359-514c28563733)
![Screenshot from 2024-10-22 07-19-33](https://github.com/user-attachments/assets/f7f3c8f6-795d-40d9-92f1-54eca6f1429f)
![Screenshot from 2024-10-22 07-19-48](https://github.com/user-attachments/assets/4555b683-eb45-4bb2-b7d1-7d0204620034)
![Screenshot from 2024-10-22 07-22-46](https://github.com/user-attachments/assets/2f0847b5-5716-4760-b00a-cceac3842680)


![Screenshot from 2024-10-22 07-29-30](https://github.com/user-attachments/assets/e746ad88-afbb-4c24-8d1c-1f042a45aa0f)
![Screenshot from 2024-10-22 07-29-35](https://github.com/user-attachments/assets/f64f1d1d-95fe-4d86-bc97-8c562f20c0fe)

![Screenshot from 2024-10-22 07-29-54](https://github.com/user-attachments/assets/aea4541a-a92d-40c6-a2e5-5b836d84c8d0)
![Screenshot from 2024-10-22 07-32-48](https://github.com/user-attachments/assets/0f98467a-6d5b-4886-be11-a533765644b5)
![Screenshot from 2024-10-22 07-33-07](https://github.com/user-attachments/assets/9f068176-5550-49d8-910c-139d6bd024d9)
![Screenshot from 2024-10-22 07-39-32](https://github.com/user-attachments/assets/4fea3f82-0074-4df7-bd06-66f3b237f407)
![Screenshot from 2024-10-22 07-36-52](https://github.com/user-attachments/assets/90f72fed-9c86-4e3e-ba0f-bf6bf101e6a9)
![Screenshot from 2024-10-22 07-36-58](https://github.com/user-attachments/assets/0bd506c6-ada7-46c3-9011-11563b722850)
![Screenshot from 2024-10-22 07-37-15](https://github.com/user-attachments/assets/6ba4bae2-bc23-4e6f-85d0-9a3d611f68e9)
![Screenshot from 2024-10-22 07-42-13](https://github.com/user-attachments/assets/5c1feaf4-487f-4233-bdee-6c7c52f43465)
![Screenshot from 2024-10-22 07-42-21](https://github.com/user-attachments/assets/176132b0-4097-45f8-bd91-1abf9b7bac77)
![Screenshot from 2024-10-22 07-55-31](https://github.com/user-attachments/assets/78b233c9-9ccb-482b-9703-779e0648cd49)
![Screenshot from 2024-10-22 07-55-38](https://github.com/user-attachments/assets/f2d11348-5428-4756-abf7-8c5f7ba42e8f)
![Screenshot from 2024-10-22 08-02-24](https://github.com/user-attachments/assets/5a322631-5df2-4e9c-a79c-ad614d18a82d)
![Screenshot from 2024-10-22 08-02-29](https://github.com/user-attachments/assets/5847b16b-063d-4581-8585-9ae7263fcd54)


![Screenshot from 2024-10-22 08-02-35](https://github.com/user-attachments/assets/dae2bd8f-b6dc-4233-8482-783a79cce034)

![Screenshot from 2024-10-22 08-04-21](https://github.com/user-attachments/assets/b8ea4e59-6ab2-482c-b23c-0fc36ca57e3d)
![Screenshot from 2024-10-22 08-07-36](https://github.com/user-attachments/assets/487ba769-712c-4e2b-bebf-40f786f7fed4)

![Screenshot from 2024-10-22 08-07-40](https://github.com/user-attachments/assets/14fe9369-d2f2-4051-b915-339e26cd7702)
![Screenshot from 2024-10-22 08-07-45](https://github.com/user-attachments/assets/e072a1a0-37f3-4b17-a918-dbcf94d5e081)

![Screenshot from 2024-10-22 08-09-56](https://github.com/user-attachments/assets/a2429524-215c-44f7-801a-4ec383f5b757)
![Screenshot from 2024-10-22 08-09-45](https://github.com/user-attachments/assets/1b73c988-c62f-45f0-b815-ffce8792eef1)

![Screenshot from 2024-10-22 08-12-41](https://github.com/user-attachments/assets/03b7014b-bf2e-4a31-98fa-3a2de9ad3c62)
![Screenshot from 2024-10-22 08-12-49](https://github.com/user-attachments/assets/491666f8-c620-44d1-a26b-f84ad5c336c7)
![Screenshot from 2024-10-22 08-13-00](https://github.com/user-attachments/assets/e40e561f-9b7d-4d0a-bd05-42951fa105f6)
![Screenshot from 2024-10-22 08-15-00](https://github.com/user-attachments/assets/ec1ef8f5-1591-47a0-805a-9347390b8a4e)
![Screenshot from 2024-10-22 08-15-06](https://github.com/user-attachments/assets/30865a1c-757d-4f3a-b743-75c1770954dc)


![Screenshot from 2024-10-22 08-15-54](https://github.com/user-attachments/assets/eff43544-edb9-4611-91a8-48c733b7db1e)
![Screenshot from 2024-10-22 08-21-00](https://github.com/user-attachments/assets/1417f7ef-104a-4e20-96f3-54ff570e1969)

![Screenshot from 2024-10-22 08-21-06](https://github.com/user-attachments/assets/b4bc0644-7361-45ca-aa64-45e411d48fea)
![Screenshot from 2024-10-22 08-25-56](https://github.com/user-attachments/assets/089bd66d-4e1e-4a3e-a91c-26b3f20a9f39)

![Screenshot from 2024-10-22 08-26-05](https://github.com/user-attachments/assets/d4cd16f3-6f6e-4941-89d7-24b75436c06a)
![Screenshot from 2024-10-22 08-26-10](https://github.com/user-attachments/assets/40923541-10f8-41d6-a2a2-37306b3ad26d)
![Screenshot from 2024-10-22 08-26-23](https://github.com/user-attachments/assets/8235173d-d7b0-4c3f-9a95-6a6da9af1ace)

![Screenshot from 2024-10-22 08-26-29](https://github.com/user-attachments/assets/630eec1a-7d5d-4f27-a60d-974bae9d12d7)

# Task 10 RISC-V Synthesis for Gate-Level Simulation of BabySoC:

## Synthesis of RISCV Core:

```

yosys
read_liberty -lib sky130_fd_sc_hd__tt_025C_1v80.lib 
read_verilog rvmyth.v 
read_verilog clk_gate.v 
synth -top rvmyth
abc -liberty sky130_fd_sc_hd__tt_025C_1v80.lib 
write_verilog -noattr rvmyth_netlist.v
show rvmyth
!gedit rvmyth
```
![Screenshot from 2024-10-24 14-14-38](https://github.com/user-attachments/assets/7bb865ec-f173-47fe-bf8c-a2e3ec0867cd)

![Screenshot from 2024-10-24 14-15-55](https://github.com/user-attachments/assets/61fa22ee-13eb-483d-949d-663e1deb2bd5)




![Screenshot from 2024-10-24 05-29-29](https://github.com/user-attachments/assets/9a9037e9-f27d-4783-9bf6-19e20b607702)
![Screenshot from 2024-10-24 05-39-54](https://github.com/user-attachments/assets/92a89998-d052-4d26-843c-95adf40f5168)

![Screenshot from 2024-10-24 05-40-20](https://github.com/user-attachments/assets/3dc34cc0-ff61-4f80-8262-e2094e07a97d)
![Screenshot from 2024-10-24 05-40-45](https://github.com/user-attachments/assets/5f2e153e-bba0-405a-935c-0ba39473e88e)


## Pre Synthesis Simulation:

![Screenshot from 2024-10-24 08-23-40](https://github.com/user-attachments/assets/ddacaa07-d837-4560-ab6c-71a617bcd1eb)

![Screenshot from 2024-10-24 08-25-49](https://github.com/user-attachments/assets/6a44e89f-2719-4a47-a9d5-cd291c5673f7)
pre synthesis output waveform O1
![Screenshot from 2024-10-24 15-04-34](https://github.com/user-attachments/assets/e805c255-8faf-42fb-a9a5-f810f9f9f301)
### pre synthesis outpur waveform with 20 cycles



## BabySoC Post Synthesis Simulation:
### Commands for Gate-Level Simulation:
```
cd BabySoC_Simulation
git clone https://github.com/Subhasis-Sahu/BabySoC_Simulation

```
### Waveform of post synthesis simulation:
```
cd src/module
iverilog -o post_synth.out primitives.v sky130_fd_sc_hd.v testbench.v -D POST_SYNTH_SIM
./post_synth.out
gtkwave post_synth_sim.vcd
```
![Screenshot from 2024-10-24 11-53-00](https://github.com/user-attachments/assets/37250615-a74e-4bbe-9bee-daa956d99e02)
### post synthesis output waveform
![Screenshot from 2024-10-24 11-54-14](https://github.com/user-attachments/assets/410f388a-b43b-4b6b-8cdf-a3b0eec995a5)

### post synthesis output waveform with  20 cycles

![Screenshot from 2024-10-24 12-51-25](https://github.com/user-attachments/assets/af8df2c9-705e-46d9-a42a-959404393067)
![Screenshot from 2024-10-24 15-17-43](https://github.com/user-attachments/assets/dd029461-7b19-4ebd-93af-33abefab7bf3)

Hence the from the above simulations of the waveforms we can find the pre synthesis and the post synthesis are same hence 
O1=O2


# Task 11 Static Timing Analysis on RISCV Core using Custom Clock Time Period of 9.55ns:

## Tools Installation:
```
cd
tar xvfz cudd-3.0.0.tar.gz
cd cudd-3.0.0
./configure
make
```
### Open sta
```
cd
sudo apt-get install cmake clang gcc tcl swig bison flex

git clone https://github.com/parallaxsw/OpenSTA.git
cd OpenSTA
cmake -DCUDD_DIR=/home/likith/cudd-3.0.0
make
app/sta
```
![Screenshot from 2024-10-28 20-28-27](https://github.com/user-attachments/assets/b03e8803-3080-49df-9fce-11bb63522aaf)
![Screenshot from 2024-10-28 20-39-51](https://github.com/user-attachments/assets/1cd1ebee-5f35-4260-9ede-c6a48b05f362)


## SDC File Configuration:
```
# Define the clock period
set PERIOD 9.55ns

# Set timing units to nanoseconds (ns)
set_units -time ns

# Create a clock named 'clk' with a period of 9.55nsns, based on the pll/CLK pin
create_clock [get_pins {pll/CLK}] -name clk -period $PERIOD

# Define setup uncertainty as 5% of the clock period
set_clock_uncertainty -setup [expr $PERIOD * 0.05] [get_clocks clk]

# Define clock transition time as 5% of the clock period
set_clock_transition [expr $PERIOD * 0.05] [get_clocks clk]

# Define hold uncertainty as 8% of the clock period
set_clock_uncertainty -hold [expr $PERIOD * 0.08] [get_clocks clk]

# Define input transition times for the specified ports
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_CP]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_VCO]
set_input_transition [expr $PERIOD * 0.08] [get_ports REF]
set_input_transition [expr $PERIOD * 0.08] [get_ports VCO_IN]
set_input_transition [expr $PERIOD * 0.08] [get_ports VREFH]
```

## Timing Analysis:
```
cd VSDBabySoc/src
sta

# Load Liberty files for cell delays and constraints
read_liberty -min ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -min ./lib/avsdpll.lib
read_liberty -min ./lib/avsddac.lib
read_liberty -max ./lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_liberty -max ./lib/avsdpll.lib
read_liberty -max ./lib/avsddac.lib

# Load the synthesized Verilog file
read_verilog ../output/synth/vsdbabysoc.synth.v

# Link the design for analysis
link_design vsdbabysoc

# Apply timing constraints from the SDC file
read_sdc ./sdc/vsdbabysoc_synthesis.sdc

# Generate a detailed timing report including min/max delays
report_checks -path_delay min_max -format full_clock_expanded -digits 4
```

## Timing Report:
![Screenshot from 2024-10-28 20-53-26](https://github.com/user-attachments/assets/65e38c98-a702-4e3b-80e9-add989ba4488)
### Setup time analysis:
![Screenshot from 2024-10-28 20-53-32](https://github.com/user-attachments/assets/c045e4db-7c0d-4216-8a3e-5f7f8b2fe848)
### Hold time analysis:
![Screenshot from 2024-10-28 20-54-01](https://github.com/user-attachments/assets/2d76df19-dc06-4c04-9815-37ffc4f6743b)
clock period of 9.55ns


# Lab11 PVT Corner Analysis for Synthesized VSDBabySoC using OpenSTA:

## List of library files for PVT corners:



![Screenshot from 2024-11-05 13-55-05](https://github.com/user-attachments/assets/3bf0b1b3-cff4-4d89-a222-76c1152e32f6)


![Screenshot from 2024-11-05 14-07-58](https://github.com/user-attachments/assets/aa0e57cf-ac73-4f7d-b637-bf0f68c3b4a3)

## SDC constraints for VSDBabySoC:
```
set PERIOD 9.55
set_units -time ns
create_clock [get_ports {clk}] -name clk -period $PERIOD
set_clock_uncertainty -setup  [expr $PERIOD * 0.05] [get_clocks clk]
set_clock_transition [expr $PERIOD * 0.05] [get_clocks clk]
set_clock_uncertainty -hold [expr $PERIOD * 0.08] [get_clocks clk]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_CP]
set_input_transition [expr $PERIOD * 0.08] [get_ports ENb_VCO]
set_input_transition [expr $PERIOD * 0.08] [get_ports REF]
set_input_transition [expr $PERIOD * 0.08] [get_ports VCO_IN]
set_input_transition [expr $PERIOD * 0.08] [get_ports VREFH]
```


![Screenshot from 2024-11-05 14-57-14](https://github.com/user-attachments/assets/b6b5f2e5-bb37-4c62-8f57-8f9ea7ab9e9e)




## Analysis Report:
### table of slack report:




![Screenshot from 2024-11-05 15-05-31](https://github.com/user-attachments/assets/2cb388f1-be0e-49ee-83ee-64c0b7248c73)


## Total Negative Slack:


![Screenshot from 2024-11-05 14-24-10](https://github.com/user-attachments/assets/bfeb8dfe-dda3-46b5-b3c6-a57e9bd1d947)

## Worst (Negative slack)Setup Slack:







![Screenshot from 2024-11-05 14-25-02](https://github.com/user-attachments/assets/277ea22f-f5df-47cb-a069-25bac3c0ae6f)

## Worst Setup Slack:





![Screenshot from 2024-11-05 14-32-18](https://github.com/user-attachments/assets/d1ba7ea5-266c-47f9-9c8c-24507ce4779a)

## Worst Hold Slack:






![Screenshot from 2024-11-05 14-36-04](https://github.com/user-attachments/assets/182ef318-e595-48b8-b0d2-a368b3f887b9)

# LAB 12: Advanced Physical Design using OpenLane:



# Digital VLSI SoC Design and Planning
![image](https://github.com/user-attachments/assets/4b585a91-a7ae-47be-a6c7-35f11bf59d69)


### 1.Run ```picorv32a``` design synthesis using OpenLANE flow and generate necessary outputs.

Commands to invoke the OpenLANE flow and perform synthesis

```
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker

# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is ```picorv32a```
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Exit from OpenLANE flow
exit

# Exit from OpenLANE flow docker sub-system
exit

```


#### 1. Run 'picorv32a' design synthesis using OpenLANE flow and generate necessary outputs.

Screen shots of the terminal:

![Screenshot from 2024-11-15 05-56-08](https://github.com/user-attachments/assets/7566c129-d4ea-460f-9078-b00644f1b2d4)
![Screenshot from 2024-11-15 05-56-15](https://github.com/user-attachments/assets/a7c52520-bab3-4b99-adac-4b4b5c28c5a3)
![Screenshot from 2024-11-15 06-11-22](https://github.com/user-attachments/assets/6321117b-302b-4a24-9907-9c6b2a8219b9)
![day1-3](https://github.com/user-attachments/assets/18c965ff-52b0-4170-aeff-2967b6f98bff)

#### 2. Calculate the flop ratio.

Screenshots of synthesis statistics report file highlighted

![day1-4](https://github.com/user-attachments/assets/6f84ae73-bcef-46b9-b351-b6f78a1c917a)

![day1-5](https://github.com/user-attachments/assets/449a9a73-61de-4039-b917-0b7ef8ee9f63)

Calculation of Flop Ratio and DFF % from synthesis statistics report file

```math
Flop\ Ratio = \frac{1613}{14876} = 0.108429685
```
```math
Percentage\ of\ DFF's = 0.108429685 * 100 = 10.84296854\ \%
```

## DAY2:Good floorplan vs bad floorplan and introduction to library cells:


### Implementation

Section 2 tasks:- 
1. Run 'picorv32a' design floorplan using OpenLANE flow and generate necessary outputs.
2. Calculate the die area in microns from the values in floorplan def.
3. Load generated floorplan def in magic tool and explore the floorplan.
4. Run 'picorv32a' design congestion aware placement using OpenLANE flow and generate necessary outputs.
5. Load generated placement def in magic tool and explore the placement.



####  Run picorv32a design floorplan using OpenLANE flow and generate necessary outputs.

Commands to invoke the OpenLANE flow and perform floorplan

Commands to invoke the OpenLANE flow and perform floorplan
```
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is ```picorv32a```
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Now we can run floorplan
run_floorplan
```
Screenshot of above commands

![day2-1](https://github.com/user-attachments/assets/64bd4fa8-4cc2-49a7-94ad-434717f37ad3)
![day2-3](https://github.com/user-attachments/assets/c6dc5725-c942-4deb-a10b-447f8cc6bece)
#### 2. Calculate the die area in microns from the values in floorplan def.

Screenshot of contents of floorplan def

![day2-4](https://github.com/user-attachments/assets/380a25eb-b01e-406a-80e7-77aab207434e)
According to floorplan
According to floorplan def 1000 Unit Distance = 1 micron Die
Die width in unit distance = 660685  0 = 660685
Die height in unit distance = 671405  0 = 671405
Distance in microns = Value in unit distance / 1000 
Die width in microns = 660685/1000 = 660.685 microns 
Dieheight in microns = 671405/1000 = 671.405 microns 
Area of die in microns = 660.685  671.405 = 443587.212425 square microns


#### 3. Load generated floorplan def in magic tool and explore the floorplan.

Commands to load floorplan def in magic in another terminal
```
# Change directory to path containing generated floorplan def
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_19-25/results/floorplan/

# Command to load the floorplan def in magic tool
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
```


Screenshots of floorplan def in magic

![day2-5](https://github.com/user-attachments/assets/5285d33a-f6f8-4de8-a8b1-ffce9fa40a50)
![day2-6](https://github.com/user-attachments/assets/a7e4703b-4733-4599-ad6c-de3d94b87042)
![day2-7](https://github.com/user-attachments/assets/9ecb9a74-33bd-4655-a1e4-de96e6225b23)
![day2-8](https://github.com/user-attachments/assets/59015334-dfb4-4563-aaee-f04882f0b6a4)
![day2-9](https://github.com/user-attachments/assets/20341778-ae10-490b-b573-43421bc41bce)
![day2-10](https://github.com/user-attachments/assets/120d37e4-e5e5-4be3-b174-e8662cf4bc87)
![day2-11](https://github.com/user-attachments/assets/66443128-0691-480a-94a7-3a7ed769a1e9)

#### 4. Run 'picorv32a' design congestion aware placement using OpenLANE flow and generate necessary outputs.

Command to run placement

```tcl
# Congestion aware placement by default
run_placement
```

Screenshots of placement run
![Screenshot from 2024-11-16 10-48-45](https://github.com/user-attachments/assets/2eb43986-9557-41e9-95cb-577f1cd38f62)

![day2-13](https://github.com/user-attachments/assets/9d837eb9-cab6-4015-837a-69f01376b004)
![day2-14](https://github.com/user-attachments/assets/4504ae40-2ba8-40bc-9f1d-5513cf10598d)
####  Load generated placement def in magic tool and explore the placement.

Commands to load placement def in magic in another terminal

   
```
# Change directory to path containing generated placement def
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/14-11_19-25/results/placement/

# Command to load the placement def in magic tool
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```

Screenshots of floorplan def in magic

![day2-15](https://github.com/user-attachments/assets/0126dec4-9746-42bb-be0f-eae526cd8fc8)
![day2-16](https://github.com/user-attachments/assets/24ac93bc-90de-4919-883a-1e25aed74771)
![day2-17](https://github.com/user-attachments/assets/25832a3d-9f1d-465a-b6a9-b4076765ccc3)

Commands to exit from current run

```tcl
# Exit from OpenLANE flow
exit

# Exit from OpenLANE flow docker sub-system
exit
```



## DAY3: Design library cell using Magic Layout and ngspice characterization:

Tasks:

1.Clone custom inverter standard cell design from github repository: Standard cell design and characterization using OpenLANE flow.
2.Load the custom inverter layout in magic and explore.
3.Spice extraction of inverter in magic.
4.Editing the spice model file for analysis through simulation.
5.Post-layout ngspice simulations.
6.Find problem in the DRC section of the old magic tech file for the skywater process and fix them.

1. Clone custom inverter standard cell design from github repository
```
# Change directory to openlane
cd Desktop/work/tools/openlane_working_dir/openlane

# Clone the repository with custom inverter design
git clone https://github.com/nickson-jose/vsdstdcelldesign

# Change into repository directory
cd vsdstdcelldesign

# Copy magic tech file to the repo directory for easy access
cp /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech .

# Check contents whether everything is present
ls

# Command to open custom inverter layout in magic
magic -T sky130A.tech sky130_inv.mag &
```
![day3-1](https://github.com/user-attachments/assets/812a1add-f96d-4f97-a702-b1d17ec77fc2)
####  Load the custom inverter layout in magic and explore.
Screenshot of custom inverter layout in magic

![day3-2](https://github.com/user-attachments/assets/3469b927-de33-4fdc-9b54-3448a7152455)

![day3-3](https://github.com/user-attachments/assets/5b85b280-9249-4611-85ee-6b0d25827247)
![day3-4](https://github.com/user-attachments/assets/c540e6c3-0409-44ad-b93d-dcdd2abf021b)
![day3-5](https://github.com/user-attachments/assets/ef7da44d-bf0c-4146-bef9-be7f5ceb1bda)
![day3-6](https://github.com/user-attachments/assets/7af7c7c9-ba94-4ee5-bf9e-885e074f1f67)
![day3-7](https://github.com/user-attachments/assets/601747c4-760a-47d7-bab5-132bae5bd6dc)
![Screenshot from 2024-11-13 23-10-19](https://github.com/user-attachments/assets/4bfd1358-467f-45f8-9e05-4de204ebd7d4)

#### 3. Spice extraction of inverter in magic.

Commands for spice extraction of the custom inverter layout to be used in tkcon window of magic
```
# Check current directory
pwd

# Extraction command to extract to .ext format
extract all

# Before converting ext to spice this command enable the parasitic extraction also
ext2spice cthresh 0 rthresh 0

# Converting to ext to spice
ext2spice
```
Screenshots of above commands

![Screenshot from 2024-11-13 23-24-22](https://github.com/user-attachments/assets/83f3ac1d-4073-40f6-b425-80357790df7a)

![Screenshot from 2024-11-13 23-26-51](https://github.com/user-attachments/assets/de934246-a409-42da-9c14-b7f590d68994)
![Screenshot from 2024-11-13 23-31-10](https://github.com/user-attachments/assets/1f5988f1-5a60-449a-84ab-2d1482a08225)

![Screenshot from 2024-11-13 23-35-16](https://github.com/user-attachments/assets/d9beb774-946d-4e76-bd19-ca444304c0d2)
![Screenshot from 2024-11-13 23-39-38](https://github.com/user-attachments/assets/e1c5aa34-f2c9-4d8c-b6ce-70db2c05bb5d)

##### The above screenshots shows 
##### Screenshot of custom inverter layout in magic
##### NMOS and PMOS identified
##### Output Y connectivity to PMOS and NMOS drain verified
##### PMOS source connectivity to VDD (here VPWR) verified
##### NMOS source connectivity to VSS (here VGND) verified
##### Deleting necessary layout part to see DRC error
##### Screenshot of tkcon window after running above commands
##### Screenshot of created spice file

####  Post-layout ngspice simulation:

Commands for ngspice simulation
```
# Command to directly load spice file for simulation to ngspice
ngspice sky130_karinv.spice

#  we have entered ngspice with the simulation spice file loaded we just have to load the plot
plot y vs time a
```


![Screenshot from 2024-11-13 23-43-16](https://github.com/user-attachments/assets/2314bdb2-8b91-40c0-af96-0bdd766eeed7)
![Screenshot from 2024-11-13 23-44-35](https://github.com/user-attachments/assets/756711f9-a6cb-420e-8890-27f1e066832b)
Screenshot of generated plot
![Screenshot from 2024-11-14 00-30-23](https://github.com/user-attachments/assets/e2bfcba3-46f6-4b6d-8b74-61cc214b5795)
![Screenshot from 2024-11-14 00-33-47](https://github.com/user-attachments/assets/498144bb-ea24-4b69-9d32-f4a49c09c3b4)

Rise transition time calculation
* Rise transition time calculation Rise Transition Time = Time taken for output to rise to 80%  Time taken for output to rise to 20%
* 20% of output (3.3V) = 0.66V
* 80% of output (3.3V) = 2.64V



20% Screenshots
![Screenshot from 2024-11-14 00-35-47](https://github.com/user-attachments/assets/1525c458-d009-473d-89d9-28bccd8ee974)
![Screenshot from 2024-11-14 00-36-30](https://github.com/user-attachments/assets/dca148e8-58a8-4f4c-9e55-97478d6ccd51)

80% Screenshots
![Screenshot from 2024-11-14 00-43-59](https://github.com/user-attachments/assets/b6692420-fb63-4800-a258-021ef17c3ab3)
![Screenshot from 2024-11-14 00-46-06](https://github.com/user-attachments/assets/5033c3e1-c2f1-4dae-aff6-ba5b9b6ad4e6)


```math
Rise\ transition\ time = 2.24638 - 2.18242 = 0.06396\ ns = 63.96\ ps
```




Fall transition time calculation

* Fall Transition Time = Time taken for output to fall to 80%  Time taken for output to fall to 20% 
* 20% of the output (3.3V) = 0.66V
* 80% of the output (3.3V) = 2.64V

20% Screenshots
![Screenshot from 2024-11-14 00-49-50](https://github.com/user-attachments/assets/5015c7dc-b8a6-4af9-86b6-8c803da80079)

![Screenshot from 2024-11-14 00-49-50](https://github.com/user-attachments/assets/c75cd46f-9984-4598-89ae-b8612d829aa2)


![Screenshot from 2024-11-14 00-50-53](https://github.com/user-attachments/assets/500bbb7d-9a15-4c61-a4bc-ae464d88b83f)

80% Screenshots

![Screenshot from 2024-11-14 01-00-46](https://github.com/user-attachments/assets/9fcd3410-29bc-48fc-9b5a-2da5b1a25210)
![Screenshot from 2024-11-14 01-01-11](https://github.com/user-attachments/assets/199653c2-7573-4a56-bbbe-4b8890d98422)

**Fall Transition Time = 4.0935ns - 4.0505ns = 0.043ns or 43ps**

* Rise Cell Delay
Calculation Rise cell delay = Time taken by output to rise to 50%  Time taken by input to fall to 50% 
* 50 % of the output (3.3V) = 1.65V


50% Screenshots


![Screenshot from 2024-11-14 01-08-18](https://github.com/user-attachments/assets/38f89248-cd56-4829-bb62-c971a7fc95f8)
![Screenshot from 2024-11-14 01-08-26](https://github.com/user-attachments/assets/0e23ff26-ff64-4cba-9c18-a9d485d58582)


**Rise Cell Delay = 2.2066ns - 2.1487ns = 0.0579 or 57.9ps**

* Fall Cell Delay
Calculation Fall cell delay = Time taken by output to fall to 50%  Time taken by input to rise to 50% 
* 50 % of the output (3.3V) = 1.65V

50% Screenshots

![Screenshot from 2024-11-14 01-12-57](https://github.com/user-attachments/assets/878f0910-8336-4753-90e5-2326d638ad05)
![Screenshot from 2024-11-14 01-13-14](https://github.com/user-attachments/assets/b446df8c-055a-4c22-9394-44df493ec0fd)

**Fall Cell Delay = 4.0751ns - 4.0498ns = 0.0253ns or 25.3ps**


####  Find problem in the DRC section of the old magic tech file for the skywater process and fix them.

Link to Sky130 Periphery rules: [https://skywater-pdk.readthedocs.io/en/main/rules/periphery.html](https://skywater-pdk.readthedocs.io/en/main/rules/periphery.html)

Commands to download and view the corrupted skywater process magic tech file and associated files to perform drc corrections
```
# Change to home directory
cd

# Command to download the lab files
wget http://opencircuitdesign.com/open_pdks/archive/drc_tests.tgz

# Since lab file is compressed command to extract it
tar xfz drc_tests.tgz

# Change directory into the lab folder
cd drc_tests

# List all files and directories present in the current directory
ls -al

# Command to view .magicrc file
gvim .magicrc

# Command to open magic tool in better graphics
magic -d XR &
```

Screenshots of commands run
![Screenshot from 2024-11-14 01-19-36](https://github.com/user-attachments/assets/967f0ed6-269f-4f54-ad24-6db6aa4eda59)
![Screenshot from 2024-11-14 01-19-40](https://github.com/user-attachments/assets/12a84818-e76f-4f8e-9bf2-dfe2ed08e11d)

Screenshot of .magicrc file
![Screenshot from 2024-11-14 01-20-01](https://github.com/user-attachments/assets/4b58d3ec-af12-427e-a9b3-e3374c5a271c)
Incorrectly implemented poly.9 simple rule correction

Screenshot of poly rules


![Screenshot 2024-11-16 114025](https://github.com/user-attachments/assets/4d2f056c-0e0d-46a3-b6e0-b818e07cfc02)
Incorrectly implemented poly.9 rule

![Screenshot from 2024-11-14 01-31-39](https://github.com/user-attachments/assets/049b05f6-7c34-4b42-a351-d724b55d4145)

![Screenshot from 2024-11-14 01-31-39 - 1](https://github.com/user-attachments/assets/c8c379f2-d2ae-4f5f-adb5-fa55a85a7404)
![Screenshot from 2024-11-14 01-32-26](https://github.com/user-attachments/assets/1cf09f7f-3d53-46a1-a9ff-c9cd89f7c6f3)

New commands inserted in sky130A.tech file to update drc

![Screenshot from 2024-11-14 01-47-38](https://github.com/user-attachments/assets/7650fc7a-4b8c-4d2f-8a73-80be1f35cc9b)

![Screenshot from 2024-11-14 01-49-36](https://github.com/user-attachments/assets/e4436d80-2311-470a-9fe5-5744125bcceb)

Commands to run in tkcon window
```
# Load updated tech file
tech load sky130A.tech

# Must re-run drc check to see updated drc errors
drc check

# Selecting region displaying the new errors and getting the error messages 
drc why
```

![Screenshot from 2024-11-14 02-15-49](https://github.com/user-attachments/assets/e1bb2bd7-746b-47b6-a81a-9dfa183c8dca)


#### Incorrectly implemented difftap.2 simple rule correction

Screenshot of difftap rules


![image](https://github.com/user-attachments/assets/53df2063-71db-4903-8afe-a1edac785845)

Incorrectly implemented difftap.2 rule no drc violation even though spacing < 0.42u








![Screenshot from 2024-11-14 02-38-08](https://github.com/user-attachments/assets/3207aede-b99a-4beb-be1e-fff1219751f0)
New commands inserted in sky130A.tech file to update drc

![Screenshot from 2024-11-14 02-39-45](https://github.com/user-attachments/assets/00b1af7a-814d-4d0b-aec6-82ae1119fd51)

Commands to run in tkcon window
```
# Loading updated tech file
tech load sky130A.tech

# Must re-run drc check to see updated drc errors
drc check

# Selecting region displaying the new errors and getting the error messages 
drc why
```

![Screenshot from 2024-11-14 02-48-34](https://github.com/user-attachments/assets/63c590f4-0d3c-44ba-a5a2-6c941cd7e853)



Incorrectly implemented nwell.4 complex rule correction

Screenshot of nwell rules
![image](https://github.com/user-attachments/assets/afab3de9-cc69-436b-95d4-2c47d52bfd32)

Incorrectly implemented nwell.4 rule no drc violation even though no tap present in nwell


![Screenshot from 2024-11-14 02-51-04](https://github.com/user-attachments/assets/d3c57be3-3655-4696-9e3a-c04cedd89023)
New commands inserted in sky130A.tech file to update drc
![Screenshot from 2024-11-14 02-52-26](https://github.com/user-attachments/assets/df90bea1-465c-4b07-8efa-d152805bb735)
![Screenshot from 2024-11-14 03-00-20](https://github.com/user-attachments/assets/35ca2426-4533-45d0-b9c7-2daff8bc37c8)

Commands to run in tkcon window

```tcl
# Load updated tech file
tech load sky130A.tech

# Change drc style to drc full
drc style drc(full)

# Must re-run drc check to see updated drc errors
drc check

# Selecting region displaying the new errors and getting the error messages 
drc why
```



![Screenshot from 2024-11-14 03-03-59](https://github.com/user-attachments/assets/e90469f8-47b4-458d-a7ea-926816bc40d6)



## DAY 4: Pre-layout timing analysis and importance of good clock tree:

<br>

## Final steps for RTL2GDS using tritonRoute and openSTA:
1. Fix up small DRC errors and verify the design is ready to be inserted into our flow.

Conditions to be verified before moving forward with custom designed cell layout:
```
    Condition 1: The input and output ports of the standard cell should lie on the intersection of the vertical and horizontal tracks.
    Condition 2: Width of the standard cell should be odd multiples of the horizontal track pitch.
    Condition 3: Height of the standard cell should be even multiples of the vertical track pitch.
```

Commands to open the custom inverter layout
```
# Change directory to vsdstdcelldesign
cd Desktop/work/tools/openlane_working_dir/openlane/vsdstdcelldesign

# Command to open custom inverter layout in magic
magic -T sky130A.tech sky130_karinv.mag &
```

Screenshot of tracks.info of sky130_fd_sc_hd


![Screenshot from 2024-11-14 03-31-18](https://github.com/user-attachments/assets/92b7c762-034f-466c-adb3-a42bf60386bd)



Commands for tkcon window to set grid as tracks of local layer

```tcl
# Get syntax for grid command
help grid

# Set grid values accordingly
grid 0.46um 0.34um 0.23um 0.17um
```

![Screenshot from 2024-11-14 03-41-29](https://github.com/user-attachments/assets/cf627c66-0096-409c-af77-719419328321)
![Screenshot from 2024-11-14 03-45-33](https://github.com/user-attachments/assets/fb334962-445f-4b4e-a5cf-a3d873b4b17c)

Condition 1 verified
![Screenshot from 2024-11-14 03-47-15](https://github.com/user-attachments/assets/5eed805c-8afd-4ce5-b645-d4f9f9970faa)

Condition 2 verified


![Screenshot from 2024-11-14 03-57-02](https://github.com/user-attachments/assets/4892b62d-d501-4fc2-ac88-18e9d6c810bd)




Condition 3 verified

![Screenshot from 2024-11-14 04-00-01](https://github.com/user-attachments/assets/9cc1b04b-2219-43e2-babc-b66ed43832ca)


####  Save the finalized layout with custom name and open it.

Command for tkcon window to save the layout with custom name

```tcl
# Command to save as
save sky130_nitheesh.mag
```

Command to open the newly saved layout

```bash
# Command to open custom inverter layout in magic
magic -T sky130A.tech sky130_nitheesh.mag &
```

Screenshot of newly saved layout





![Screenshot from 2024-11-14 04-02-18](https://github.com/user-attachments/assets/9a0380db-51b2-41a9-a622-74ae7a19b39f)


####  Generate lef from the layout.

Command for tkcon window to write lef

```tcl
# lef command
lef write
```

Screenshot of command run

![Screenshot from 2024-11-14 04-04-00](https://github.com/user-attachments/assets/a79a75b0-e47e-4c77-8169-7d9f97b88803)

Screenshot of newly created lef file
![Screenshot from 2024-11-14 04-07-58](https://github.com/user-attachments/assets/72ebe93f-4ea4-4619-b5a2-8b3bfe3bfb35)


####  Copy the newly generated lef and associated required lib files to 'picorv32a' design 'src' directory.

Commands to copy necessary files to 'picorv32a' design 'src' directory

```bash
# Copy lef file
cp sky130_nitheesh.lef ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/

# List and check whether it's copied
ls ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/

# Copy lib files
cp libs/sky130_fd_sc_hd__* ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/

# List and check whether it's copied
ls ~/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/src/
```

Screenshot of commands run


![Screenshot from 2024-11-14 04-17-36](https://github.com/user-attachments/assets/cc11fa2f-c033-4584-a3a0-cd8ab7525585)


####  Edit 'config.tcl' to change lib file and add the new extra lef into the openlane flow.

Commands to be added to config.tcl to include our custom cell in the openlane flow

Commands to be added to config.tcl to include our custom cell in the openlane flow
```
set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]
```

Edited config.tcl to include the added lef and change library to ones we added in src directory
![Screenshot from 2024-11-14 04-30-31](https://github.com/user-attachments/assets/1fbfea99-903b-4746-930a-851a1c44ef86)

#### 6. Run openlane flow synthesis with newly inserted custom inverter cell.
```
Commands to invoke the OpenLANE flow include new lef and perform synthesis 
Commands to invoke the OpenLANE flow include new lef and perform synthesis

# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker

# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Adiitional commands to include newly added lef to openlane flow
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis
```
Terminal Screenshots for the above commands






![Screenshot from 2024-11-14 04-37-56](https://github.com/user-attachments/assets/9d11bfdd-3d0c-4ace-9100-4ed1ba9a9afa)
![Screenshot from 2024-11-14 04-38-18](https://github.com/user-attachments/assets/686737af-8eef-498a-928e-914487e92efa)
![Screenshot from 2024-11-14 04-38-49](https://github.com/user-attachments/assets/ac8d0d92-d01f-41ca-aa11-1932ab78490a)


####  Remove/reduce the newly introduced violations with the introduction of custom inverter cell by modifying design parameters.

Noting down current design values generated before modifying parameters to improve timing
![Screenshot from 2024-11-14 04-40-08](https://github.com/user-attachments/assets/9ea6e431-c891-4a6c-9cbe-522b1a89e7f7)

![Screenshot from 2024-11-14 04-40-20](https://github.com/user-attachments/assets/86b53e61-dd36-4745-b455-47590da1ceaa)



Screenshot of merged.lef in `tmp` directory with our custom inverter as macro
![Screenshot from 2024-11-16 14-53-58](https://github.com/user-attachments/assets/135692fd-239f-4a46-9c3a-547f08dd2f32)

Commands to view and change parameters to improve timing and run synthesis
```
# Now once again we have to prep design so as to update variables
prep -design picorv32a -tag 16-11_10-46 -overwrite

# Addiitional commands to include newly added lef to openlane flow merged.lef
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to display current value of variable SYNTH_STRATEGY
echo $::env(SYNTH_STRATEGY)

# Command to set new value for SYNTH_STRATEGY
set ::env(SYNTH_STRATEGY) "DELAY 3"

# Command to display current value of variable SYNTH_BUFFERING to check whether it's enabled
echo $::env(SYNTH_BUFFERING)

# Command to display current value of variable SYNTH_SIZING
echo $::env(SYNTH_SIZING)

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Command to display current value of variable SYNTH_DRIVING_CELL to check whether it's the proper cell or not
echo $::env(SYNTH_DRIVING_CELL)

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis
```


Screenshots of commands run


![Screenshot from 2024-11-14 04-44-39](https://github.com/user-attachments/assets/2248d5f0-7e42-4b99-8a8a-93678b2dbbb0)
![Screenshot from 2024-11-14 04-59-19](https://github.com/user-attachments/assets/cb66804d-813b-4171-9a34-4cfe5183d14e)
![Screenshot from 2024-11-14 04-59-37](https://github.com/user-attachments/assets/da282f95-6669-4130-967d-0bc759f6c3ca)
![Screenshot from 2024-11-14 04-59-52](https://github.com/user-attachments/assets/4375d1ee-35e4-445b-a4f0-b60706742c11)

![Screenshot from 2024-11-14 05-05-13](https://github.com/user-attachments/assets/2c324100-8492-40ea-bcad-f3138c373701)


####  Once synthesis has accepted our custom inverter we can now run floorplan and placement and verify the cell is accepted in PnR flow.

Now that our custom inverter is properly accepted in synthesis we can now run floorplan using following command

```tcl
# Now we can run floorplan
run_floorplan
```

Screenshots of command run
![Screenshot from 2024-11-14 05-05-34](https://github.com/user-attachments/assets/9a4f06a8-93f5-45f5-8bbd-18cd6b5adc94)
![Screenshot from 2024-11-14 05-06-45](https://github.com/user-attachments/assets/2d6efe00-0255-4ac1-90f4-0ced279f9b8a)
![Screenshot from 2024-11-14 05-09-05](https://github.com/user-attachments/assets/85fc2ad3-46b1-4f74-ae72-74df6a3f4f19)
![Screenshot from 2024-11-14 05-09-25](https://github.com/user-attachments/assets/00b39eb8-a610-4eb5-8714-7499ec94d34b)


 we are facing error while using run_floorplan command
```tcl
# Follwing commands are alltogather sourced in "run_floorplan" command
init_floorplan
place_io
tap_decap_or
```

Screenshots of commands run

![Screenshot from 2024-11-14 05-10-36](https://github.com/user-attachments/assets/b878472e-746f-4993-b108-a45c5731570e)
![Screenshot from 2024-11-14 05-10-48](https://github.com/user-attachments/assets/3eb10c13-4c39-4a25-98e4-f2f55a8bf3d2)

Now that floorplan is done we can do placement using following command

```tcl
# Now we are ready to run placement
run_placement
```

Screenshots of command run


![Screenshot from 2024-11-14 05-12-51](https://github.com/user-attachments/assets/f7fb3aa7-2e63-4a69-9e23-1f5a06e858b3)
![Screenshot from 2024-11-14 05-13-50](https://github.com/user-attachments/assets/d69f4524-bcbe-4ed1-8081-7b71870176b4)




Commands to load placement def in magic in another terminal

Commands to load placement def in magic in another terminal
```
# Change directory to path containing generated placement def
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/16-11_10-46/results/placement/

# Command to load the placement def in magic tool
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```

![Screenshot from 2024-11-14 05-17-07](https://github.com/user-attachments/assets/905a6a41-e998-4988-a4e5-2cf8f46c777a)

Screenshot of placement def in magic
![Screenshot from 2024-11-14 05-17-42](https://github.com/user-attachments/assets/f5ac581c-ca64-4955-a30f-e86293f8898d)


Screenshot of custom inverter inserted in placement def with proper abutment


![Screenshot from 2024-11-14 06-06-43](https://github.com/user-attachments/assets/94a5d427-89f0-4595-a115-701ee6fff0f4)



![Screenshot from 2024-11-15 00-50-55](https://github.com/user-attachments/assets/1ae530bb-abee-462c-bc88-ed8c436eacdc)

![Screenshot from 2024-11-16 16-42-50](https://github.com/user-attachments/assets/ab05e2bc-849e-4041-979a-48b19315285b)




#### 9. Do Post-Synthesis timing analysis with OpenSTA tool.


Commands to invoke the OpenLANE flow include new lef and perform synthesis 

Commands to invoke the OpenLANE flow include new lef and perform synthesis
```
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker

# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Adiitional commands to include newly added lef to openlane flow
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis
```

 screenshots


![Screenshot from 2024-11-15 00-54-44](https://github.com/user-attachments/assets/d81d6450-842c-417a-b3c0-73e7a7a2f2e1)
![Screenshot from 2024-11-15 00-55-25](https://github.com/user-attachments/assets/d6fa82e0-3003-4614-b4c8-c4efe27bc9f3)
![Screenshot from 2024-11-15 00-56-11](https://github.com/user-attachments/assets/370cc54d-af5d-42d3-bd96-ee137a6d9eb0)
![Screenshot from 2024-11-15 00-57-38](https://github.com/user-attachments/assets/b3520e16-bb74-4cf6-9852-8db7861628ae)
![Screenshot from 2024-11-15 01-08-21](https://github.com/user-attachments/assets/44fdf8ab-7731-4681-842e-a933fb4d8d0e)

![Screenshot from 2024-11-16 17-21-50](https://github.com/user-attachments/assets/1ce42ac1-5ca4-422a-a390-7edfddcc8b1d)

Commands to run STA in another terminal

```bash
# Change directory to openlane
cd Desktop/work/tools/openlane_working_dir/openlane

# Command to invoke OpenSTA tool with script
sta pre_sta.conf
```

Screenshots of commands run


![Screenshot from 2024-11-15 02-03-05](https://github.com/user-attachments/assets/dda23789-f1f8-4f93-a873-d0eaabef63db)
![Screenshot from 2024-11-15 02-03-17](https://github.com/user-attachments/assets/715902b4-59c5-4c1e-82bf-1377c397ff16)
![Screenshot from 2024-11-15 02-03-32](https://github.com/user-attachments/assets/cdceb522-4fdd-429d-9efb-9fa9d43cabc4)
![Screenshot from 2024-11-15 02-03-36](https://github.com/user-attachments/assets/e1233986-983c-4d12-a22f-cd9da9fe56f7)
![Screenshot from 2024-11-15 02-03-41](https://github.com/user-attachments/assets/8876830e-8fa6-4f4f-aa32-56621ec9de96)
![Screenshot from 2024-11-15 02-03-43](https://github.com/user-attachments/assets/8510fedd-a7b8-47fa-a8c0-314d1156b1cc)
![Screenshot from 2024-11-15 02-03-46](https://github.com/user-attachments/assets/1104eb02-7469-4c1f-abc9-0fe637ccc58e)



Since more fanout is causing more delay we can add parameter to reduce fanout and do synthesis again

Since more fanout is causing more delay we can add parameter to reduce fanout and do synthesis again

Commands to include new lef and perform synthesis
```
# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a -tag 16-11_10-46 -overwrite

# Adiitional commands to include newly added lef to openlane flow
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Command to set new value for SYNTH_MAX_FANOUT
set ::env(SYNTH_MAX_FANOUT) 4

# Command to display current value of variable SYNTH_DRIVING_CELL to check whether it's the proper cell or not
echo $::env(SYNTH_DRIVING_CELL)

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis
```

![Screenshot from 2024-11-15 02-18-18](https://github.com/user-attachments/assets/772e3117-6d1e-49db-9eaf-1351ea8a2df2)
![Screenshot from 2024-11-15 02-18-49](https://github.com/user-attachments/assets/4e2638c7-febb-40dc-945e-566b5a8e983e)



![Screenshot from 2024-11-15 02-20-25](https://github.com/user-attachments/assets/5bde631d-dd56-4e03-b5f0-e14e082715ce)
![Screenshot from 2024-11-15 02-21-35](https://github.com/user-attachments/assets/dffe7974-45d5-4d05-9309-34bf4b1494db)


Commands to run STA in another terminal

```bash
# Change directory to openlane
cd Desktop/work/tools/openlane_working_dir/openlane

# Command to invoke OpenSTA tool with script
sta pre_sta.conf
```

Screenshots of commands run


![Screenshot from 2024-11-15 02-23-03](https://github.com/user-attachments/assets/fc320623-4e28-43ca-82aa-17ebc7751d82)
![Screenshot from 2024-11-15 02-23-10](https://github.com/user-attachments/assets/f84f1697-67f8-438b-bcf9-01778a141e90)
![Screenshot from 2024-11-15 02-23-14](https://github.com/user-attachments/assets/ce7166b8-5c09-4c47-bc45-93a020097ce2)
![Screenshot from 2024-11-15 02-23-19](https://github.com/user-attachments/assets/5a815946-73ed-45fc-97dc-d1d90aa9484d)
![Screenshot from 2024-11-15 02-23-22](https://github.com/user-attachments/assets/09484819-4e0a-473d-b688-8d1dcab6c619)
![Screenshot from 2024-11-15 02-23-25](https://github.com/user-attachments/assets/af000f04-ea2f-4edd-8bd1-05bd08e0a75d)
![Screenshot from 2024-11-15 02-23-27](https://github.com/user-attachments/assets/a0b20368-c03f-47ff-92b1-0bb1eaa3b654)

####  Make timing ECO fixes to remove all violations.

OR gate of drive strength 2 is driving 4 fanouts

![Screenshot from 2024-11-15 02-28-05](https://github.com/user-attachments/assets/ed91f2c7-6158-4706-b560-bb1e48317e1f)


Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4
Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4
```
# Reports all the connections to a net
report_net -connections _11672_

# Checking command syntax
help replace_cell

# Replacing cell
replace_cell _14510_ sky130_fd_sc_hd__or3_4

# Generating custom timing report
report_checks -fields {net cap slew input_pins} -digits 4
```

Result - slack reduced
![Screenshot from 2024-11-15 02-29-28](https://github.com/user-attachments/assets/c8dc21d2-c095-4802-8d7a-da1969e64e8d)
![Screenshot from 2024-11-15 02-30-40](https://github.com/user-attachments/assets/8b9ad150-f2da-4d11-9cf1-00cc972430bb)
![Screenshot from 2024-11-15 02-31-12](https://github.com/user-attachments/assets/d6e30556-4e5d-402c-9b2d-0608e459d7ff)
![Screenshot from 2024-11-15 02-31-40](https://github.com/user-attachments/assets/7b0357fd-d4d8-4e32-b076-20c0ef251409)

OR gate of drive strength 2 is driving 4 fanouts
![Screenshot from 2024-11-15 02-32-14](https://github.com/user-attachments/assets/f0b406ae-05b4-44d8-8fbf-aa244c45e69d)


Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4
```
# Reports all the connections to a net
report_net -connections _11675_

# Replacing cell
replace_cell _14514_ sky130_fd_sc_hd__or3_4

# Generating custom timing report
report_checks -fields {net cap slew input_pins} -digits 4
```



![Screenshot from 2024-11-15 02-33-34](https://github.com/user-attachments/assets/c0dcd6ac-bbec-4ff0-8c49-bf84b354304c)

![Screenshot from 2024-11-15 02-34-20](https://github.com/user-attachments/assets/58f9e915-e803-4972-9297-e9c4b7df255f)
![Screenshot from 2024-11-15 02-34-37](https://github.com/user-attachments/assets/79f4c95b-7dd5-45dc-87bf-d8cf3fd9cffc)
![Screenshot from 2024-11-15 02-35-10](https://github.com/user-attachments/assets/1b0d40fe-e477-4cf0-b354-938c2e693332)

![Screenshot from 2024-11-15 02-35-21](https://github.com/user-attachments/assets/b75cfa7d-8324-48d6-ac26-56c51a3e1a9f)


Commands to perform analysis and optimize timing by replacing with OR gate of drive strength 4

```tcl
# Reports all the connections to a net
report_net -connections _11643_

# Replacing cell
replace_cell _14481_ sky130_fd_sc_hd__or4_4

# Generating custom timing report
report_checks -fields {net cap slew input_pins} -digits 4
```

Result - slack reduced


![Screenshot from 2024-11-15 02-36-29](https://github.com/user-attachments/assets/00f67f10-ec8a-47db-a1e1-3b18055d1e37)
![Screenshot from 2024-11-15 02-36-58](https://github.com/user-attachments/assets/b5ec8a7a-02bf-4266-94d5-97da8097ccc7)
![Screenshot from 2024-11-15 02-38-05](https://github.com/user-attachments/assets/179ef2a6-21fd-43d3-bce5-a657a9bf087f)

Commands to verify instance `_14506_`  is replaced with `sky130_fd_sc_hd__or4_4`

```tcl
# Generating custom timing report
report_checks -from _29043_ -to _30440_ -through _14506_
```

Screenshot of replaced instance


![Screenshot from 2024-11-15 02-39-12](https://github.com/user-attachments/assets/ac588e98-d9e9-44f5-b4b0-400a8f4dc7fc)
![Screenshot from 2024-11-15 02-39-42](https://github.com/user-attachments/assets/b4d3f924-0abc-4cb0-a2b3-36c714c0b4d6)



Commands to verify instance `_14506_`  is replaced with `sky130_fd_sc_hd__or4_4`

```tcl
# Generating custom timing report
report_checks -from _29043_ -to _30440_ -through _14506_
```

Screenshot of replaced instance
![Screenshot from 2024-11-15 02-41-41](https://github.com/user-attachments/assets/78f24827-f52a-463c-b01b-836059af78b1)
![Screenshot from 2024-11-15 02-42-02](https://github.com/user-attachments/assets/cb738f13-5d9d-4d69-b1c1-e78fd58bcd2a)





#### 11. Replace the old netlist with the new netlist generated after timing ECO fix and implement the floorplan, placement and cts.

Now to insert this updated netlist to PnR flow and we can use `write_verilog` and overwrite the synthesis netlist but before that we are going to make a copy of the old old netlist

Commands to make copy of netlist
```
# Change from home directory to synthesis results directory
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/16-11_10-46/results/synthesis/

# List contents of the directory
ls

# Copy and rename the netlist
cp picorv32a.synthesis.v picorv32a.synthesis_old.v

# List contents of the directory
ls
```


Screenshot of commands run

![Screenshot from 2024-11-15 02-45-56](https://github.com/user-attachments/assets/457a08ce-4912-4e7c-8759-c880525a54a7)


Commands to write verilog

```tcl
# Check syntax
help write_verilog

# Overwriting current synthesis netlist
write_verilog /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/16-11_10-46/results/synthesis/picorv32a.synthesis.v

# Exit from OpenSTA since timing analysis is done
exit
```

Screenshot of commands run



![Screenshot from 2024-11-15 02-50-52](https://github.com/user-attachments/assets/6ff1438e-ff75-4f28-a419-0188311e777d)



![Screenshot from 2024-11-17 03-06-32](https://github.com/user-attachments/assets/d1787871-42e5-4b96-bc30-3e32119644a2)


![Screenshot from 2024-11-17 03-15-22](https://github.com/user-attachments/assets/9e8e31ad-689f-4a29-87c6-ff6d6ae9417c)





Since we confirmed that netlist is replaced and will be loaded in PnR but since we want to follow up on the earlier 0 violation design we are continuing with the clean design to further stages

Commands load the design and run necessary stages

```tcl
# Now once again we have to prep design so as to update variables
prep -design picorv32a -tag 16-11_10-46 -overwrite

# Addiitional commands to include newly added lef to openlane flow merged.lef
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to set new value for SYNTH_STRATEGY
set ::env(SYNTH_STRATEGY) "DELAY 3"

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Follwing commands are alltogather sourced in "run_floorplan" command
init_floorplan
place_io
tap_decap_or

# Now we are ready to run placement
run_placement

# Incase getting error
unset ::env(LIB_CTS)

# With placement done we are now ready to run CTS
run_cts
```

Screenshots of commands run


![Screenshot from 2024-11-15 02-58-29](https://github.com/user-attachments/assets/778c35dd-d51d-4e91-a636-f2a1e58793b7)
![Screenshot from 2024-11-15 03-00-45](https://github.com/user-attachments/assets/c0d0c104-2249-47aa-9c54-c6606ac717d8)
![Screenshot from 2024-11-15 03-04-23](https://github.com/user-attachments/assets/aef72dba-fdee-4054-92de-64d2ef062330)
![Screenshot from 2024-11-15 03-06-38](https://github.com/user-attachments/assets/880ee2f0-a5d0-4e01-9c06-3db4ce3e2313)
![Screenshot from 2024-11-15 03-06-56](https://github.com/user-attachments/assets/b6d157d7-a4c2-47c1-a878-52f670ac0b14)
![Screenshot from 2024-11-15 03-07-15](https://github.com/user-attachments/assets/66c95864-10d2-4983-927b-3e90d232309c)

![Screenshot from 2024-11-15 03-08-50](https://github.com/user-attachments/assets/b9d7d541-2051-4fc8-97a7-533ce4182bcc)




#### 12. Post-CTS OpenROAD timing analysis.

Commands to be run in OpenLANE flow to do OpenROAD timing analysis with integrated OpenSTA in OpenROAD

```tcl
# Command to run OpenROAD tool
openroad

# Reading lef file
read_lef /openLANE_flow/designs/picorv32a/runs/16-11_10-46/tmp/merged.lef

# Reading def file
read_def /openLANE_flow/designs/picorv32a/runs/16-11_10-46/results/cts/picorv32a.cts.def

# Creating an OpenROAD database to work with
write_db pico_cts.db

# Loading the created database in OpenROAD
read_db pico_cts.db

# Read netlist post CTS
read_verilog /openLANE_flow/designs/picorv32a/runs/16-11_10-46/results/synthesis/picorv32a.synthesis_cts.v

# Read library for design
read_liberty $::env(LIB_SYNTH_COMPLETE)

# Link design and library
link_design picorv32a

# Read in the custom sdc we created
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc

# Setting all cloks as propagated clocks
set_propagated_clock [all_clocks]

# Check syntax of 'report_checks' command
help report_checks

# Generating custom timing report
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4

# Exit to OpenLANE flow
exit
```

Screenshots of commands run and timing report generated

![Screenshot from 2024-11-15 03-10-06](https://github.com/user-attachments/assets/8c4292dc-a91c-4601-a7b6-3049a7a3a7a7)

![Screenshot from 2024-11-15 03-15-43](https://github.com/user-attachments/assets/1d603829-802c-4f0c-912c-296c3297fdda)
![Screenshot from 2024-11-15 03-15-57](https://github.com/user-attachments/assets/b6d6c4e2-a55f-40d0-8d3c-ab7fba9286f6)
![Screenshot from 2024-11-15 03-17-38](https://github.com/user-attachments/assets/a4af2c30-6cb8-42fe-9596-b571a17e457e)

![Screenshot from 2024-11-15 03-58-18](https://github.com/user-attachments/assets/587ca94f-997e-4062-a48d-31edbff018f6)
![Screenshot from 2024-11-15 04-01-59](https://github.com/user-attachments/assets/8a70d871-46a5-4253-b7a5-da88b5fec78d)
![Screenshot from 2024-11-15 04-04-56](https://github.com/user-attachments/assets/0fc5f755-29b6-4569-a4f8-aea9b51ebbf6)
![Screenshot from 2024-11-15 04-05-46](https://github.com/user-attachments/assets/17bba38e-68a2-40b1-a3b7-e6fed6f752a8)
![Screenshot from 2024-11-15 04-06-05](https://github.com/user-attachments/assets/75ddd42d-f676-40ae-a675-1a0a324d0c36)
![Screenshot from 2024-11-15 04-06-17](https://github.com/user-attachments/assets/118e09c0-8117-4676-bc8c-ff4d37ed1c33)
![Screenshot from 2024-11-15 04-06-20](https://github.com/user-attachments/assets/c34057cf-45fe-4d80-a2fb-e51b1b0d0f13)




#### 13. Explore post-CTS OpenROAD timing analysis by removing 'sky130_fd_sc_hd__clkbuf_1' cell from clock buffer list variable 'CTS_CLK_BUFFER_LIST'.

Commands to be run in OpenLANE flow to do OpenROAD timing analysis after changing `CTS_CLK_BUFFER_LIST`

```tcl
# Checking current value of 'CTS_CLK_BUFFER_LIST'_/results/cts/picorv32a.cts.def

# Creating an OpenROAD database to work with
write_db pico_cts1.db

# Loading the created database in OpenROAD
read_db pico_cts.db

# Read netlist post CTS
read_verilog /openLANE_flow/designs/picorv32a/runs/16-11_10-46/results/synthesis/picorv32a.synthesis_cts.v

# Read library for design
read_liberty $::env(LIB_SYNTH_COMPLETE)

# Link design and library
link_design picorv32a

# Read in the custom sdc we created
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc

# Setting all cloks as propagated clocks
set_propagated_clock [all_clocks]

# Generating custom timing report
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4

# Report hold skew
report_clock_skew -hold

# Report setup skew
report_clock_skew -setup

# Exit to OpenLANE flow
exit

# Checking current value of 'CTS_CLK_BUFFER_LIST'
echo $::env(CTS_CLK_BUFFER_LIST)

# Inserting 'sky130_fd_sc_hd__clkbuf_1' to first index of list
set ::env(CTS_CLK_BUFFER_LIST) [linsert $::env(CTS_CLK_BUFFER_LIST) 0 sky130_fd_sc_hd__clkbuf_1]

# Checking current value of 'CTS_CLK_BUFFER_LIST'
echo $::env(CTS_CLK_BUFFER_LIST)
```

Screenshots of commands run and timing report generated
![Screenshot from 2024-11-15 05-42-06](https://github.com/user-attachments/assets/85394457-2d97-4171-aae6-47d504dbc2a8)
![Screenshot from 2024-11-15 05-43-01](https://github.com/user-attachments/assets/3006c7d6-31a6-4d6a-bce0-8bd06d36f347)
![Screenshot from 2024-11-15 05-45-17](https://github.com/user-attachments/assets/8819fe3b-3408-40e3-848c-e7b137c7f4e6)
![Screenshot from 2024-11-15 05-47-59](https://github.com/user-attachments/assets/235ced7a-b20d-4e66-8fde-6d6e89aea36b)
![Screenshot from 2024-11-15 05-48-15](https://github.com/user-attachments/assets/f4f6b10e-c2bd-4849-97db-706bf38cbb39)
![Screenshot from 2024-11-15 05-48-54](https://github.com/user-attachments/assets/3d1b7010-348a-481d-9454-840b67c32301)
![Screenshot from 2024-11-15 05-48-59](https://github.com/user-attachments/assets/31652d21-6e85-4145-9611-a45322072329)
![Screenshot from 2024-11-15 05-49-23](https://github.com/user-attachments/assets/8a5d28e5-83b9-42b6-a16b-4d1212008458)
![Screenshot from 2024-11-15 05-50-37](https://github.com/user-attachments/assets/c9a9455b-8a34-4ee4-9fb1-53a7636b8550)
![Screenshot from 2024-11-15 05-50-40](https://github.com/user-attachments/assets/34bcbc79-fce2-4191-988e-aabeaa20496a)


## DAY1- Final steps for RTL2GDS using tritonRoute and openSTA

1. Perform generation of Power Distribution Network (PDN) and explore the PDN layout.

Commands to perform all necessary stages up until now
```
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker

# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Addiitional commands to include newly added lef to openlane flow merged.lef
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to set new value for SYNTH_STRATEGY
set ::env(SYNTH_STRATEGY) "DELAY 3"

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Following commands are alltogather sourced in "run_floorplan" command
init_floorplan
place_io
tap_decap_or

# Now we are ready to run placement
run_placement

# Incase getting error
unset ::env(LIB_CTS)

# With placement done we are now ready to run CTS
run_cts

# Now that CTS is done we can do power distribution network
gen_pdn 
```

Screenshots of power distribution network run


![Screenshot from 2024-11-15 04-28-11](https://github.com/user-attachments/assets/d26c6d2e-5060-4184-b270-d6c66f0ea0c3)
![Screenshot from 2024-11-15 04-29-16](https://github.com/user-attachments/assets/2651b35b-9fe5-466f-b826-b887c7fa3f50)
![Screenshot from 2024-11-15 04-30-54](https://github.com/user-attachments/assets/eff5fb15-afe6-4b80-b8f3-e03a02e04638)
![Screenshot from 2024-11-15 04-32-05](https://github.com/user-attachments/assets/bf253d92-b2d1-47a0-aa76-bf48ba9e5307)




Commands to load PDN def in magic in another terminal

```bash
# Change directory to path containing generated PDN def
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/18-11_18-17/tmp/floorplan/

# Command to load the PDN def in magic tool
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read 14-pdn.def &
```

Screenshots of PDN def
![Screenshot from 2024-11-15 04-35-34](https://github.com/user-attachments/assets/2a67a4ed-54e1-4170-a2fd-e661497b8c00)
![Screenshot from 2024-11-15 04-35-47](https://github.com/user-attachments/assets/474a8be8-933c-452c-a33f-b1d0e8ba9d1b)




#### 2. Perfrom detailed routing using TritonRoute and explore the routed layout.

Command to perform routing

```tcl
# Check value of 'CURRENT_DEF'
echo $::env(CURRENT_DEF)

# Check value of 'ROUTING_STRATEGY'
echo $::env(ROUTING_STRATEGY)

# Command for detailed route using TritonRoute
run_routing
```

Screenshots of routing run

![Screenshot from 2024-11-15 04-41-23](https://github.com/user-attachments/assets/9455ec98-fe23-4c03-8b8c-5f6f05532a84)
![Screenshot from 2024-11-15 04-46-19](https://github.com/user-attachments/assets/7193ea52-25aa-4a73-8896-a854f4f78c9d)
![Screenshot from 2024-11-15 04-46-58](https://github.com/user-attachments/assets/9bddf29a-d92e-4fd4-bda5-539e39a6c58c)

![Screenshot from 2024-11-15 05-01-50](https://github.com/user-attachments/assets/b0fc944b-0827-4433-b95f-98e8ecd1c781)
![Screenshot from 2024-11-15 05-01-53](https://github.com/user-attachments/assets/1c70f5af-fffb-4be5-93f0-d542d38f6673)


Commands to load routed def in magic in another terminal

```bash
# Change directory to path containing routed def
cd Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/18-11_18-17/results/routing/

# Command to load the routed def in magic tool
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.def &
```

Screenshots of routed def


![Screenshot from 2024-11-15 05-02-17](https://github.com/user-attachments/assets/cdde7f7b-0e72-4faf-ae7f-09f12b713fee)
![Screenshot from 2024-11-15 05-02-23](https://github.com/user-attachments/assets/2b613ffa-fe8b-4df0-8be7-af415ce99ecf)
![Screenshot from 2024-11-15 05-02-48](https://github.com/user-attachments/assets/b0ea8457-a90b-4414-becb-da72dc5623a2)
![Screenshot from 2024-11-15 05-04-05](https://github.com/user-attachments/assets/2ba4801c-f8fe-468d-b591-365e61dacf56)


#### 3. Post-Route parasitic extraction using SPEF extractor.

Commands for SPEF extraction using external tool

```bash
# Change directory
cd Desktop/work/tools/SPEF_EXTRACTOR

# Command extract spef
python3 main.py /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/26-03_08-45/tmp/merged.lef /home/vsduser/Desktop/work/tools/openlane_working_dir/openlane/designs/picorv32a/runs/18-11_18-17/results/routing/picorv32a.def
```

#### 4. Post-Route OpenSTA timing analysis with the extracted parasitics of the route.

Commands to be run in OpenLANE flow to do OpenROAD timing analysis with integrated OpenSTA in OpenROAD

```tcl
# Command to run OpenROAD tool
openroad

# Reading lef file
read_lef /openLANE_flow/designs/picorv32a/runs/18-11_18-17/tmp/merged.lef

# Reading def file
read_def /openLANE_flow/designs/picorv32a/runs/18-11_18-17/results/routing/picorv32a.def

# Creating an OpenROAD database to work with
write_db pico_route.db

# Loading the created database in OpenROAD
read_db pico_route.db

# Read netlist post CTS
read_verilog /openLANE_flow/designs/picorv32a/runs/18-11_18-17/results/synthesis/picorv32a.synthesis_preroute.v

# Read library for design
read_liberty $::env(LIB_SYNTH_COMPLETE)

# Link design and library
link_design picorv32a

# Read in the custom sdc we created
read_sdc /openLANE_flow/designs/picorv32a/src/my_base.sdc

# Setting all cloks as propagated clocks
set_propagated_clock [all_clocks]

# Read SPEF
read_spef /openLANE_flow/designs/picorv32a/runs/18-11_18-17/results/routing/picorv32a.spef

# Generating custom timing report
report_checks -path_delay min_max -fields {slew trans net cap input_pins} -format full_clock_expanded -digits 4

# Exit to OpenLANE flow
exit
```

Screenshots of commands run and timing report generated


![Screenshot from 2024-11-15 05-11-29](https://github.com/user-attachments/assets/6537edf0-32c8-4589-8310-484688a03921)
![Screenshot from 2024-11-15 05-13-23](https://github.com/user-attachments/assets/2ef22bf1-6d4b-4d12-bb44-95e2df8d2f48)
![Screenshot from 2024-11-15 05-16-20](https://github.com/user-attachments/assets/8feecd43-4d63-4122-ab19-4d0c5e488ce1)
![Screenshot from 2024-11-15 05-16-49](https://github.com/user-attachments/assets/c7aebb12-8da9-4d09-aba5-63010e91d810)


# Lab14: RTL to GDSII flow for the RVMYTH RISC-V core and VSDBabySoC
## OpenROAD & Flow controllers:
### Overview of OpenROAD and Flow Controllers
OpenROAD is a sophisticated tool designed for integrated chip physical design, facilitating the transition from Register Transfer Level (RTL) to GDSII. It encompasses a wide range of processes including synthesis, floorplanning, placement, routing, signoff parasitic extraction, and timing analysis.

The tool employs a hierarchical placement algorithm with the primary goal of minimizing wire length, while also offering features aimed at optimizing both timing and power consumption. OpenROADs architecture is designed to be flexible and extensible, allowing users to incorporate their own algorithms and features as needed.
### Flow Controllers in OpenROAD
The OpenROAD project includes two principal flow controllers:
### 1)OpenROAD Flow Scripts (ORFS):
ORFS is an open-source flow controller that streamlines the automated design process for digital ASICs, guiding the design from synthesis to layout. This flow controller offers a fully automated RTL-to-GDSII design process, encompassing various stages such as Synthesis, Placement and Routing (PnR), Static Timing Analysis (STA), Design Rule Check (DRC), and Layout Versus Schematic (LVS) checks.
The main objective of ORFS is to provide a customizable and flexible environment for digital ASIC design, enabling users to select and integrate different tools according to their specific requirements.
Within the ORFS framework, OpenROAD functions as a plugin during the physical design phase. This integration allows for extensive configuration and customization to align with project-specific needs. The OpenROAD plugin offers advanced capabilities, including hierarchical placement, global routing, and detailed routing optimization.
ORFS is compatible with various public and private Process Design Kits (PDKs), with available public PDKs including GF180, Skywater130, and ASAP7.
### 2)OpenLane:
OpenLane represents a fully automated RTL-to-GDSII design flow, akin to ORFS, and is developed by Efabless specifically for the Skywater130 Multi-Project Wafer (MPW) Program.

 ## Process of ORFS:
 ### Steps for Configuring and Using OpenROAD Flow Scripts (ORFS)
 ### Setup and Configuration:
 After installing ORFS, the first step is to tailor the framework according to your projects requirements. This involves defining various design parameters, including the target technology node, design constraints, and specific tool configurations.

 ### Design Entry Methods:
 ORFS accommodates multiple design entry methods. Users can input their designs in various formats, with Verilog being one of the supported options.

 ### Synthesis Process:
 The synthesis phase is critical as it converts the RTL design into a gate-level netlist. ORFS provides access to a range of open-source synthesis tools, including Yosys and ABC, which are suitable for this conversion.

 ### Floorplanning:
 During the floorplanning phase, the arrangement of design modules within the chips area is established. ORFS offers several tools for this task, including RePlAce and Capo.

 ### Placement:
 The placement stage focuses on determining the precise locations of each gate or cell within the chip. OpenROAD is one of the placement tools integrated into ORFS for this purpose.

 ### Routing:
 In the routing phase, connections between gates and cells are created using metal wires, completing the circuit design. ORFS includes routing tools like FastRoute and TritonRoute to assist in this process.

 ### Layout Verification:
 Following routing, the design undergoes layout verification to ensure correctness. Tools such as Magic, which are part of the ORFS suite, are utilized for this verification.

 ### GDSII File Generation:
 After successful verification, the final step is to generate the GDSII layout file. This is accomplished using ORFS tools like Magic and KLayout, which facilitate the creation of the final output for manufacturing.





## Installing of OpenRoad Flow Script:
Following link is to install ORFS with tools 
```https://github.com/The-OpenROAD-Project/OpenROAD-flow-scripts/blob/master/docs/user/BuildLocally.md```

commands for installing ORFS:
```
git clone --recursive https://github.com/The-OpenROAD-Project/OpenROAD-flow-scripts
cd OpenROAD-flow-scripts
sudo ./setup.sh
./build_openroad.sh --local
```
Executing flow of gcd  for nangate45 pdk
Installing yosys and openroad

![Screenshot from 2024-11-26 01-01-18](https://github.com/user-attachments/assets/4bf40c51-b6ee-44f2-8913-a6d81c7f9801)

flowrun verification
```
make gui_final
```


![Screenshot from 2024-11-26 01-08-33](https://github.com/user-attachments/assets/0583cf94-a7fa-43fe-b3da-db6740760153)


![img2](https://github.com/user-attachments/assets/ccba40dc-dc14-443f-afe2-467436d9bd9c)


## ORFS for RVMYTH RISC-V :
config.mk file 
```
export DESIGN_NICKNAME = rvmyth
export DESIGN_NAME = RV_CPU
export PLATFORM    = sky130hd

export VERILOG_FILES = $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/RV_CPU.v \
					   $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/include/clk_gate.v


export VERILOG_INCLUDE_DIRS = $(DESIGN_HOME)/src/$(DESIGN_NICKNAME)/include

export SDC_FILE = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/constraint.sdc

export PDN_TCL = $(DESIGN_HOME)/$(PLATFORM)/$(DESIGN_NICKNAME)/pdn.tcl

export SYNTH_HIERARCHICAL = 1
export RTLMP_FLOW ?= 1

export PLACE_PINS_ARGS = -exclude left:0-150 -exclude left:300-500: -exclude right:* -exclude top:* -exclude bottom:*

export DIE_AREA   = 0 0 600 600
export CORE_AREA  = 20 20 590 590

export MACRO_PLACE_HALO = 50 50
export MACRO_PLACE_CHANNEL = 70 70
export TNS_END_PERCENT = 100

export REMOVE_ABC_BUFFERS = 1

```

constraints file
```
set_units -time ns
set PERIOD 10.35
create_clock [get_ports {clk}] -name clk -period $PERIOD
set_clock_uncertainty [expr 0.05 * $PERIOD] -setup [get_clocks clk]
set_clock_uncertainty [expr 0.08 * $PERIOD] -hold [get_clocks clk]
set_clock_transition [expr 0.05 * $PERIOD] [get_clocks clk]

set_input_transition [expr $PERIOD * 0.08] [get_ports reset]
```
synthesis report

```
=== RV_CPU ===

   Number of wires:               7226
   Number of wire bits:           7235
   Number of public wires:        1401
   Number of public wire bits:    1410
   Number of ports:                  3
   Number of port bits:             12
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:               7095
     sky130_fd_sc_hd__a2111o_1       1
     sky130_fd_sc_hd__a2111oi_0     15
     sky130_fd_sc_hd__a2111oi_1      7
     sky130_fd_sc_hd__a2111oi_2      9
     sky130_fd_sc_hd__a2111oi_4      2
     sky130_fd_sc_hd__a211o_1        4
     sky130_fd_sc_hd__a211oi_1      11
     sky130_fd_sc_hd__a211oi_2       2
     sky130_fd_sc_hd__a21bo_2        1
     sky130_fd_sc_hd__a21boi_0       7
     sky130_fd_sc_hd__a21boi_1       1
     sky130_fd_sc_hd__a21o_1        22
     sky130_fd_sc_hd__a21o_2         1
     sky130_fd_sc_hd__a21oi_1      905
     sky130_fd_sc_hd__a221o_1        2
     sky130_fd_sc_hd__a221oi_1      92
     sky130_fd_sc_hd__a22o_1        86
     sky130_fd_sc_hd__a22oi_1      504
     sky130_fd_sc_hd__a22oi_2        2
     sky130_fd_sc_hd__a2bb2oi_2      1
     sky130_fd_sc_hd__a311o_1        3  
     sky130_fd_sc_hd__a31o_2        18
     sky130_fd_sc_hd__a31oi_1       12
     sky130_fd_sc_hd__a41oi_1        4
     sky130_fd_sc_hd__a41oi_2        1
     sky130_fd_sc_hd__and2_0         1
     sky130_fd_sc_hd__and2_1        11
     sky130_fd_sc_hd__and3_1       109
     sky130_fd_sc_hd__and3b_1        1
     sky130_fd_sc_hd__and4_1         1
     sky130_fd_sc_hd__and4b_1        1
     sky130_fd_sc_hd__buf_1         44
     sky130_fd_sc_hd__buf_12         1
     sky130_fd_sc_hd__buf_2         19
     sky130_fd_sc_hd__buf_4          2
     sky130_fd_sc_hd__buf_6          1
     sky130_fd_sc_hd__clkbuf_1     609
     sky130_fd_sc_hd__conb_1         1
     sky130_fd_sc_hd__dfxtp_1     1274
     sky130_fd_sc_hd__fa_1           3
     sky130_fd_sc_hd__ha_1         135
     sky130_fd_sc_hd__inv_1        113
     sky130_fd_sc_hd__mux2_2         1
     sky130_fd_sc_hd__mux2i_1       54
     sky130_fd_sc_hd__nand2_1     1440
     sky130_fd_sc_hd__nand2b_1      31
     sky130_fd_sc_hd__nand3_1      290
     sky130_fd_sc_hd__nand3b_1      33
     sky130_fd_sc_hd__nand4_1      128
     sky130_fd_sc_hd__nand4b_1       1
     sky130_fd_sc_hd__nor2_1       230
     sky130_fd_sc_hd__nor2b_1       51
     sky130_fd_sc_hd__nor3_1        56
     sky130_fd_sc_hd__nor3_2         2
     sky130_fd_sc_hd__nor3b_1        3
     sky130_fd_sc_hd__nor4_1        28
     sky130_fd_sc_hd__nor4_2         1
     sky130_fd_sc_hd__o2111a_1       3
     sky130_fd_sc_hd__o2111ai_1      3
     sky130_fd_sc_hd__o211a_1        1
     sky130_fd_sc_hd__o211ai_1      38
     sky130_fd_sc_hd__o21a_1         8
     sky130_fd_sc_hd__o21ai_0      242
     sky130_fd_sc_hd__o21ai_1       12
     sky130_fd_sc_hd__o21bai_1      24
     sky130_fd_sc_hd__o221ai_1      78
     sky130_fd_sc_hd__o221ai_4       1
     sky130_fd_sc_hd__o22a_1        34
     sky130_fd_sc_hd__o22ai_1       72
     sky130_fd_sc_hd__o311a_1        2
     sky130_fd_sc_hd__o311ai_0       3
     sky130_fd_sc_hd__o311ai_1       1
     sky130_fd_sc_hd__o31a_1         5
     sky130_fd_sc_hd__o31ai_1       56
     sky130_fd_sc_hd__o32a_1         2
     sky130_fd_sc_hd__o32ai_1        2
     sky130_fd_sc_hd__o41ai_1        3
     sky130_fd_sc_hd__or2_0          1
     sky130_fd_sc_hd__or2_2         11
     sky130_fd_sc_hd__or3_1         10
     sky130_fd_sc_hd__or3b_1         2
     sky130_fd_sc_hd__or3b_2         2
     sky130_fd_sc_hd__or4_1         11
     sky130_fd_sc_hd__or4b_1         1
     sky130_fd_sc_hd__xnor2_1       47
     sky130_fd_sc_hd__xnor2_2        1
     sky130_fd_sc_hd__xor2_1         9

 Chip area for module '\RV_CPU': 57322.476800
     of which used for sequential elements: 25504.460800 (44.49%)

```

screenshots of execution of flow by command make:


![Screenshot from 2024-11-26 00-54-53](https://github.com/user-attachments/assets/61f13e1d-a089-4f16-9ee7-5653edc9cc57)


![Screenshot from 2024-11-26 00-55-10](https://github.com/user-attachments/assets/0bef9328-8ee9-49b9-97ac-e1dccd73443c)



![Screenshot from 2024-11-26 00-55-17](https://github.com/user-attachments/assets/1489fdbb-07ae-4ef3-8c9f-fdbd979269d6)

![Screenshot from 2024-11-26 00-55-27](https://github.com/user-attachments/assets/6b8ce9f1-de81-462f-84d7-296ef4e4b49e)
![Screenshot from 2024-11-26 00-55-34](https://github.com/user-attachments/assets/99ec393b-f984-43ef-b9a2-6a47e1cb55f5)

![Screenshot from 2024-11-26 00-55-43](https://github.com/user-attachments/assets/dc50aee1-fb4e-49c6-b773-2afddce9c425)

![Screenshot from 2024-11-26 00-55-57](https://github.com/user-attachments/assets/842c4b48-8e9f-4a9b-96e1-04c1ae7f3506)
![Screenshot from 2024-11-26 00-56-08](https://github.com/user-attachments/assets/0f8193ed-ca4e-4c05-b4c9-4ea66b144be2)
![Screenshot from 2024-11-26 00-56-31](https://github.com/user-attachments/assets/3225e99d-71ee-4b5e-8899-9bac21de6003)


### Clock tree:

![Screenshot from 2024-11-26 02-30-12](https://github.com/user-attachments/assets/58b6be9b-a078-4968-a97b-cdc6bc25da4b)



### IR DROP:

![Screenshot from 2024-11-26 02-30-47](https://github.com/user-attachments/assets/7475db94-4aa5-4f55-9f77-18782b34ed75)

### Final placement:
![Screenshot from 2024-11-26 02-31-50](https://github.com/user-attachments/assets/f5db25c0-28d4-4d42-81c6-5ab03cb46ed5)



### Final Routing:


![Screenshot from 2024-11-26 02-33-21](https://github.com/user-attachments/assets/4372f18d-fd34-470c-9e84-f4e795f5bb42)


QOR RESULTS:

![Screenshot from 2024-11-26 01-00-30](https://github.com/user-attachments/assets/c2acbd34-4119-4e38-a309-68191cae5f67)


### CTS Final Reports:

```
==========================================================================
cts final report_checks -path_delay min
--------------------------------------------------------------------------
Startpoint: CPU_Xreg_value_a4[11][20]$_SDFFE_PP0P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: CPU_src2_value_a3[20]$_DFF_P_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: min

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.07    0.00    0.00    0.00 ^ clk (in)
                                         clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
    16    0.36    0.37    0.35    0.35 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_clk (net)
                  0.37    0.00    0.35 ^ clkbuf_4_12_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
     9    0.12    0.13    0.29    0.65 ^ clkbuf_4_12_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_12_0_clk (net)
                  0.13    0.00    0.65 ^ clkbuf_leaf_66_clk/A (sky130_fd_sc_hd__clkbuf_16)
    11    0.04    0.06    0.17    0.82 ^ clkbuf_leaf_66_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_66_clk (net)
                  0.06    0.00    0.82 ^ CPU_Xreg_value_a4[11][20]$_SDFFE_PP0P_/CLK (sky130_fd_sc_hd__dfxtp_1)
     2    0.01    0.07    0.33    1.15 ^ CPU_Xreg_value_a4[11][20]$_SDFFE_PP0P_/Q (sky130_fd_sc_hd__dfxtp_1)
                                         CPU_Xreg_value_a4[11][20] (net)
                  0.07    0.00    1.15 ^ _10862_/A1 (sky130_fd_sc_hd__a22oi_1)
     1    0.00    0.06    0.08    1.23 v _10862_/Y (sky130_fd_sc_hd__a22oi_1)
                                         _04917_ (net)
                  0.06    0.00    1.23 v _10864_/C (sky130_fd_sc_hd__nand4_1)
     1    0.01    0.09    0.13    1.36 ^ _10864_/Y (sky130_fd_sc_hd__nand4_1)
                                         _04919_ (net)
                  0.09    0.00    1.36 ^ _10870_/B1 (sky130_fd_sc_hd__o22ai_2)
     1    0.01    0.06    0.10    1.46 v _10870_/Y (sky130_fd_sc_hd__o22ai_2)
                                         _04925_ (net)
                  0.06    0.00    1.46 v _10871_/A0 (sky130_fd_sc_hd__mux2i_1)
     1    0.00    0.13    0.14    1.60 ^ _10871_/Y (sky130_fd_sc_hd__mux2i_1)
                                         CPU_src2_value_a2[20] (net)
                  0.13    0.00    1.60 ^ CPU_src2_value_a3[20]$_DFF_P_/D (sky130_fd_sc_hd__dfxtp_4)
                                  1.60   data arrival time

                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.07    0.00    0.00    0.00 ^ clk (in)
                                         clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
    16    0.36    0.37    0.35    0.35 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_clk (net)
                  0.37    0.00    0.35 ^ clkbuf_4_12_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
     9    0.12    0.13    0.29    0.65 ^ clkbuf_4_12_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_12_0_clk (net)
                  0.13    0.00    0.65 ^ clkbuf_leaf_67_clk/A (sky130_fd_sc_hd__clkbuf_16)
    12    0.04    0.06    0.17    0.82 ^ clkbuf_leaf_67_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_67_clk (net)
                  0.06    0.00    0.82 ^ CPU_src2_value_a3[20]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_4)
                          0.83    1.65   clock uncertainty
                          0.00    1.65   clock reconvergence pessimism
                         -0.05    1.60   library hold time
                                  1.60   data required time
-----------------------------------------------------------------------------
                                  1.60   data required time
                                 -1.60   data arrival time
-----------------------------------------------------------------------------
                                  0.00   slack (MET)
```

```
==========================================================================
cts final report_checks -path_delay max
--------------------------------------------------------------------------
Startpoint: CPU_imm_a3[30]$_DFF_P_
            (rising edge-triggered flip-flop clocked by clk)
Endpoint: CPU_Xreg_value_a4[8][29]$_SDFFE_PP0P_
          (rising edge-triggered flip-flop clocked by clk)
Path Group: clk
Path Type: max

Fanout     Cap    Slew   Delay    Time   Description
-----------------------------------------------------------------------------
                          0.00    0.00   clock clk (rise edge)
                          0.00    0.00   clock source latency
     1    0.07    0.00    0.00    0.00 ^ clk (in)
                                         clk (net)
                  0.00    0.00    0.00 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
    16    0.36    0.37    0.35    0.35 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_clk (net)
                  0.37    0.00    0.35 ^ clkbuf_4_3_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.11    0.13    0.29    0.64 ^ clkbuf_4_3_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_3_0_clk (net)
                  0.13    0.00    0.64 ^ clkbuf_leaf_11_clk/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.05    0.06    0.18    0.82 ^ clkbuf_leaf_11_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_11_clk (net)
                  0.06    0.00    0.82 ^ CPU_imm_a3[30]$_DFF_P_/CLK (sky130_fd_sc_hd__dfxtp_4)
    51    0.26    0.71    0.82    1.64 ^ CPU_imm_a3[30]$_DFF_P_/Q (sky130_fd_sc_hd__dfxtp_4)
                                         CPU_imm_a3[10] (net)
                  0.71    0.02    1.66 ^ _11541_/A (sky130_fd_sc_hd__ha_2)
     8    0.03    0.18    0.42    2.07 ^ _11541_/SUM (sky130_fd_sc_hd__ha_2)
                                         _05599_ (net)
                  0.18    0.00    2.07 ^ _08327_/C_N (sky130_fd_sc_hd__or3b_1)
     1    0.00    0.07    0.37    2.44 v _08327_/X (sky130_fd_sc_hd__or3b_1)
                                         _02926_ (net)
                  0.07    0.00    2.44 v _08328_/A3 (sky130_fd_sc_hd__a311o_2)
     3    0.02    0.10    0.46    2.90 v _08328_/X (sky130_fd_sc_hd__a311o_2)
                                         _02927_ (net)
                  0.10    0.00    2.90 v _08330_/D (sky130_fd_sc_hd__nand4_1)
     1    0.01    0.10    0.13    3.03 ^ _08330_/Y (sky130_fd_sc_hd__nand4_1)
                                         _02929_ (net)
                  0.10    0.00    3.03 ^ _08331_/A2_N (sky130_fd_sc_hd__a2bb2oi_2)
     2    0.02    0.23    0.24    3.28 ^ _08331_/Y (sky130_fd_sc_hd__a2bb2oi_2)
                                         _02930_ (net)
                  0.23    0.00    3.28 ^ _08332_/B (sky130_fd_sc_hd__nand2_1)
     3    0.01    0.12    0.14    3.41 v _08332_/Y (sky130_fd_sc_hd__nand2_1)
                                         _02931_ (net)
                  0.12    0.00    3.41 v _08543_/A2 (sky130_fd_sc_hd__o2111ai_1)
     1    0.00    0.14    0.19    3.60 ^ _08543_/Y (sky130_fd_sc_hd__o2111ai_1)
                                         _03134_ (net)
                  0.14    0.00    3.60 ^ _08544_/C_N (sky130_fd_sc_hd__or3b_4)
    16    0.07    0.16    0.52    4.13 v _08544_/X (sky130_fd_sc_hd__or3b_4)
                                         _03135_ (net)
                  0.16    0.01    4.13 v _09940_/C1 (sky130_fd_sc_hd__a2111oi_0)
     1    0.00    0.40    0.40    4.53 ^ _09940_/Y (sky130_fd_sc_hd__a2111oi_0)
                                         _04112_ (net)
                  0.40    0.00    4.53 ^ _09942_/B1 (sky130_fd_sc_hd__a2111oi_0)
     1    0.00    0.14    0.12    4.66 v _09942_/Y (sky130_fd_sc_hd__a2111oi_0)
                                         _00981_ (net)
                  0.14    0.00    4.66 v hold1553/A (sky130_fd_sc_hd__dlygate4sd3_1)
     1    0.00    0.05    0.58    5.24 v hold1553/X (sky130_fd_sc_hd__dlygate4sd3_1)
                                         net1666 (net)
                  0.05    0.00    5.24 v CPU_Xreg_value_a4[8][29]$_SDFFE_PP0P_/D (sky130_fd_sc_hd__dfxtp_1)
                                  5.24   data arrival time

                         10.35   10.35   clock clk (rise edge)
                          0.00   10.35   clock source latency
     1    0.07    0.00    0.00   10.35 ^ clk (in)
                                         clk (net)
                  0.00    0.00   10.35 ^ clkbuf_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
    16    0.36    0.37    0.35   10.70 ^ clkbuf_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_0_clk (net)
                  0.37    0.00   10.70 ^ clkbuf_4_13_0_clk/A (sky130_fd_sc_hd__clkbuf_16)
     8    0.11    0.13    0.29   10.99 ^ clkbuf_4_13_0_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_4_13_0_clk (net)
                  0.13    0.00   10.99 ^ clkbuf_leaf_65_clk/A (sky130_fd_sc_hd__clkbuf_16)
    11    0.04    0.06    0.17   11.17 ^ clkbuf_leaf_65_clk/X (sky130_fd_sc_hd__clkbuf_16)
                                         clknet_leaf_65_clk (net)
                  0.06    0.00   11.17 ^ CPU_Xreg_value_a4[8][29]$_SDFFE_PP0P_/CLK (sky130_fd_sc_hd__dfxtp_1)
                         -0.52   10.65   clock uncertainty
                          0.00   10.65   clock reconvergence pessimism
                         -0.11   10.54   library setup time
                                 10.54   data required time
-----------------------------------------------------------------------------
                                 10.54   data required time
                                 -5.24   data arrival time
-----------------------------------------------------------------------------
                                  5.30   slack (MET)



==========================================================================
```








# ASIC DESIGN CLASS

## LAB 1 - Create a C program which will caluculate sum from 1 to n, And compile it using GCC compilier

1)- Write a C program in text editor as sum 1 to n  

Following image will show about the image of the C program 

![image1lab1](https://github.com/user-attachments/assets/bdd30330-f82b-488c-ba6f-2216d53d4d38)

2- Compile the code using GCC compiler and run the code to see the output

Image will show about the commands used and output of sum1ton

![image2lab1](https://github.com/user-attachments/assets/c247d982-e748-4ed9-9ed5-bcae0e249202)

## LAB 2 - Compiling Lab1(sum 1 to n) C program with RISCV Compiler

1) We will run lab 1 program using RISCV Gcc compiler


![image1lab2](https://github.com/user-attachments/assets/44bf2daf-6c83-4f52-86ad-afb83a292f7c)

2)In a new tab we will check the assembly code for C program we Run

Here we went to the "main"  when I calculted using calculator got (35)dec and (23)hex 

![img3lab2](https://github.com/user-attachments/assets/d5ab9bb2-d94f-4b70-8e69-0277e7e2aabd)

4) Hence now we will use Ofast on the RISCV compiler and we will use the same C code 
image which describes about the commands


![img5lab2](https://github.com/user-attachments/assets/816cc5e4-374e-4de9-95da-b0ec6eb3158c)

5) We got 12 instructions(byte adressing) in the main section (adress 100bo)

![img6lab2](https://github.com/user-attachments/assets/3a3c8018-28fa-4629-b4c8-d561402dbbbb)

6) RISCV compilation output
 Code Compilation using RISC-V GCC compiler with a different optimization flag (Ofast)
we will compile the code with compiler flag set as -Ofast and then we will check the assembly code again
![lab 2 8](https://github.com/user-attachments/assets/9d590d74-02ef-4005-887b-16107e7326a1)
![lab 2 9](https://github.com/user-attachments/assets/f882ce66-3843-4c09-81e2-ae3fef84b769)

# LAB3-DEBBUGGING WITH SPIKE SIMULATOR AND RUNNING THE OBJECT FILE GENERATED BY RISCV COMPILER IN SPIKE STIMULATOR

1) Debug it in spike using below command and we need our program counter to run till 100b0 by using the below command
   ![lab 3 1](https://github.com/user-attachments/assets/d744c0d1-b465-4ec6-b4a5-02e805546aaf)

2) Next we have to modify the content of a0 below command
press enter then it will run the next instruction is lui a0,0*21
And then we will ger the next instruction as addi sp,sp,-16
![lab 3 3](https://github.com/user-attachments/assets/1f3a1111-bd80-4306-a799-d8f71cb4dbef)


3)As stack pointer content updated by -16. Quit the spike by pressing q 
![lab 3 4](https://github.com/user-attachments/assets/a1440c67-95cf-44d4-a004-9d784f0ac688)

4)And we will follow the steps as follow from step1(Enter the spike stimulation again)
![Screenshot 2024-07-28 131139](https://github.com/user-attachments/assets/ffe17813-aed3-4399-9f54-e1d929df54a2)

Hex value
3ffffffb50-3ffffffb40=10 , 
Dec value
274877905744-274877905728=16

# task 4
## RISC-V Instruction Types and Formats

### R-type: Used for register-register operations.

    Format: funct7 (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)

### I-type: Used for immediate operations.

    Format: imm[11:0] (12 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)
### S-type: Used for store operations.

    Format: imm[11:5] (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:0] (5 bits) | opcode (7 bits)
### B-type: Used for branch operations.

    Format: imm[12] (1 bit) | imm[10:5] (6 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | imm[4:1] (4 bits) | imm[11] (1 bit) | opcode (7 bits)
### U-type: Used for upper immediate operations.

    Format: imm[31:12] (20 bits) | rd (5 bits) | opcode (7 bits)
### J-type: Used for jump operations.

    Format: imm[20] (1 bit) | imm[10:1] (10 bits) | imm[11] (1 bit) | imm[19:12] (8 bits) | rd (5 bits) | opcode (7 bits)
## Encoded Instructions
### ADD r0, r1, r2

    Type: R
    Encoding: 0000000 00010 00001 000 00000 0110011
    Binary: 00000000001000001000000000110011
### SUB r2, r0, r1

    Type: R
    Encoding: 0100000 00000 00001 000 00010 0110011
    Binary: 01000000000000001000000010110011
### AND r1, r0, r2

    Type: R
    Encoding: 0000000 00010 00000 111 00001 0110011
    Binary: 00000000001000000111000010110011
### OR r8, r1, r5

    Type: R
    Encoding: 0000000 00101 00001 110 01000 0110011
    Binary: 00000000010100001110010000110011
### XOR r8, r0, r4

    Type: R
    Encoding: 0000000 00100 00000 100 01000 0110011
    Binary: 00000000010000000100010000110011
### SLT r0, r1, r4

    Type: R
    Encoding: 0000000 00100 00001 010 00000 0110011
    Binary: 00000000010000001010000000110011
### ADDI r2, r2, 5

    Type: I
    Encoding: 000000000101 00010 000 00010 0010011
    Binary: 00000000010100010000000010010011
### SW r2, r0, 4

    Type: S
    Encoding: 0000000 00010 00000 010 00100 0100011
    Binary: 00000000001000000010001000100011
### SRL r6, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 101 00110 0110011
    Binary: 00000000000100001101000110110011
### BNE r0, r0, 20

    Type: B
    Encoding: 000000 00000 00000 001 01000 1100011
    Binary: 00000000000000000001001000110011
### BEQ r0, r0, 15

    Type: B
    Encoding: 000000 00000 00000 000 01111 1100011
    Binary: 00000000000000000000001111110011
### LW r3, r1, 2

    Type: I
    Encoding: 000000000010 00001 010 00011 0000011
    Binary: 00000000001000001010000011000011
### SLL r5, r1, r1

    Type: R
    Encoding: 0000000 00001 00001 001 00101 0110011
    Binary: 00000000000100001001000101110011


    


| Instruction        | Type | 32-bit Instruction Code                        | Binary Representation            | Hexadecimal Representation |
|--------------------|------|------------------------------------------------|----------------------------------|-----------------------------|
| ADD r0, r1, r2  | R    | 0000000 00010 00001 000 00000 0110011       | 00000000001000001000000000110011 | 0x00028233 |
| SUB r2, r0, r1  | R    | 0100000 00001 00000 000 00010 0110011       | 01000000000100000000000000110011 | 0x40028033 |
| AND r1, r0, r2  | R    | 0000000 00010 00000 111 00001 0110011       | 00000000001000000111100000110011 | 0x0000f033 |
| OR r8, r1, r5   | R    | 0000000 00101 00001 110 01000 0110011       | 00000000010100001110010000110011 | 0x0002e433 |
| XOR r8, r0, r4  | R    | 0000000 00100 00000 100 01000 0110011       | 00000000010000000100100000110011 | 0x00029033 |
| SLT r00, r1, r4 | R    | 0000000 00100 00001 010 00000 0110011       | 00000000010000001010000000110011 | 0x0002a033 |
| ADDI r02, r2, 5 | I    | 000000000101 00010 000 00010 0010011       | 0000000001010001000000000010011 | 0x0002a013 |
| SW r2, r0, 4    | S    | 000000000100 00000 010 00010 0100011       | 00000000010000000001000000100011 | 0x00008023 |
| SRL r06, r01, r1| R    | 0000000 00001 00001 101 00110 0110011       | 00000000001000001010100110011001 | 0x0002a033 |
| BNE r0, r0, 20  | B    | 000000000101 00000 001 00000 1100011       | 00000000010100000001000001100011 | 0x00014063 |
| BEQ r0, r0, 15  | B    | 000000000111 00000 000 00000 1100011       | 00000000011100000000000001100011 | 0x0000c063 |
| LW r03, r01, 2  | I    | 000000000010 00001 010 00011 0000011       | 00000000001000001010000010000011 | 0x00010283 |
| SLL r05, r01, r1| R    | 0000000 00001 00001 001 00101 0110011       | 00000000001000001001000100110011 | 0x00024033 |

# TASK 5

## Using above RISC-V Core Verilog netlist and testbench in functional test bench simulation experiment

### We are running this code with gtkwave and icarur

## Identifying Instruction Types
### Given hardcoded instructions are:
![Screenshot 2024-08-11 075657](https://github.com/user-attachments/assets/6d197141-d9a4-441d-ace5-03172e2eb743)

## 1.ADD r6,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 082834](https://github.com/user-attachments/assets/6e7014b7-ef69-4cf4-bd6c-67397bc244d9)


## 2. SUB r7,r1,r2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 083019](https://github.com/user-attachments/assets/d71d659f-5391-40ac-aec7-2f2c9d97405e)


## 3.AND r8.r1,r3
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084628](https://github.com/user-attachments/assets/d691dd2a-43d8-4990-a62b-cc664986a137)


## 4.OR r9,r2,r5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084710](https://github.com/user-attachments/assets/90538f99-6a2b-4298-9531-89e6e7ac6799)


## 5. XOR r10,r1,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084741](https://github.com/user-attachments/assets/e2090eb6-f21e-4414-b197-2b0474fa0905)


## 6.SLT r1,r2,r4
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084816](https://github.com/user-attachments/assets/65b70148-9075-4c1d-972a-008e43f6c157)


## 7. ADDI r12,r4,5
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084857](https://github.com/user-attachments/assets/7006f8f1-523c-40b9-89ca-fa6b4ca7d4c6)


## 8. SW r3,r1,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 084929](https://github.com/user-attachments/assets/41241c69-8082-4cb7-9d4e-0f6c14a4ed53)


## 9. LW r13,r01,2
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085008](https://github.com/user-attachments/assets/25012151-20a2-4f8e-948d-ee1c78177995)


## 10. BEQ r0,r0,15
### Waveform of the hardcopy verilog program:
![Screenshot 2024-08-11 085036](https://github.com/user-attachments/assets/aeef1ad0-fa57-4f88-abd0-c94205e6ae5e)


## WAVEFORM OF OUR VERILOG PROGRAM:

### B. Given instructions of our verilog program:








